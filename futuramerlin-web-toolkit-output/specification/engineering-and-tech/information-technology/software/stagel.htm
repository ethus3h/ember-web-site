<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <link href="/simple.css" rel="stylesheet" type="text/css"> <meta content="Ember" name="author"> <meta content="width=device-width,height=device-height,user-scalable=yes" name="viewport"> <meta name="generator" content="Futuramerlin Web Toolkit 2.3.79"> <title>StageL: Simple staging language &mdash; Ember</title> </head> <body> <input class="nav-trigger" id="nav-trigger" type="checkbox"> <label for="nav-trigger">&nbsp;</label> <nav> <p class="logo"> <a class="nodecorate logolink" href="/">ember</a> </p> <ul> <li>Navigation:</li> <li class="nav-item nav-item-inactive"> <a href="/">Home</a> </li> <li class="nav-item nav-item-inactive"> <a href="/news">News</a> </li> <li class="nav-item nav-item-inactive"> <a href="/ancillary/ready-to-use.htm">Software</a> </li> <li class="nav-item nav-item-inactive"> <a href="/components.htm">Primary project components</a> </li> <li class="nav-item nav-item-inactive"> <a href="/people">People</a> </li> </ul> <a href="#">&#x1F51D;&#xFE0E;</a> </nav> <main> <h1>StageL: Simple staging language</h1> <p class="breadcrumbs">Page location: <span><a href="/components.htm">Core project components</a></span> <span><a href="/specification">Specification</a></span> <span><a href="/specification/engineering-and-tech">Engineering and Technology</a></span> <span><a href="/specification/engineering-and-tech/information-technology">Information technology</a></span> <span><a href="/specification/engineering-and-tech/information-technology/software">Information Technology Software Environment</a></span> </p><nav id="toc"><h2>Table of Contents</h2> <ol><li><a href="#Overview">Overview</a></li> <li><a href="#Design_goals">Design goals</a></li> <li><a href="#Actual_results_of_the_design_goals">Actual results of the design goals</a></li> <li><a href="#Syntax">Syntax</a> <ol><li><a href="#Gotchas">Gotchas</a></li> <li><a href="#Example">Example</a></li> </ol></li> <li><a href="#Special_syntaxes">Special syntaxes</a></li> <li><a href="#Scope">Scope</a></li> <li><a href="#Errors">Errors</a></li> <li><a href="#Types_and_basic_commands_for_them">Types and basic commands for them</a> <ol><li><a href="#b:_Booleans">b: Booleans</a></li> <li><a href="#n:_Numbers_.28integer_only.29">n: Numbers (integer only)</a></li> <li><a href="#s:_Strings">s: Strings</a></li> <li><a href="#Basic_type_utility_routines">Basic type utility routines</a></li> <li><a href="#Array_utility_routines">Array utility routines</a></li> <li><a href="#an:_Number_Arrays">an: Number Arrays</a></li> <li><a href="#ab:_Boolean_Arrays">ab: Boolean Arrays</a></li> <li><a href="#as:_String_Arrays">as: String Arrays</a></li> </ol></li> <li><a href="#StageR_commands">StageR commands</a> <ol><li><a href="#Booleans">Booleans</a></li> <li><a href="#Numbers">Numbers</a></li> <li><a href="#Strings">Strings</a></li> <li><a href="#Arrays">Arrays</a></li> </ol></li> </ol> </nav> <h2 id="Overview">Overview</h2> <p>A simple programming language is provided for easily writing portable algorithms to be transpiled to and used by programs in other languages. The name "StageL" comes from calling it a "staging language" (which refers to its being a tool for developing the main EITE software, which should provide a more complete language). This project was inspired by the ugly code that resulted when I tried to write using these principles directly in JavaScript, needing a lot of easy-to-mess-up boilerplate code and awkward notation (largely because it is not strongly typed).</p> <h2 id="Design_goals">Design goals</h2> <ul> <li>Imperative language. Trivial to implement, learn, and read; extremely portable.</li> <li>Provide function calls, arrays, strings, numbers, booleans, and operators for these types with strict typing. Objects and first-class functions are out of scope for this language. (It's closer to duck-typed in practice, as e.g. in Bash there would be no distinction between string 0 and number 0.)</li> <li>Implemented as a transpiler that accepts a file as input and produces a file in the target language as output.</li> <li>Have an implementation of itself using itself, to provide testing and portability of the language.</li> <li>Have an implementation in Bash.</li> <li>Should transpile to (eventually) JavaScript, C, Java, Bash, PHP, Microsoft CIL, Lisp, x86 assembly, and Python, at least, in roughly that order of priority. (JavaScript has been completed for work on the main EITE software; C and Java should follow soon thereafter for their portability; the other languages are nice to have to cover a diverse range of development environments, and additionally, in the case of CIL/x86 assembly/Lisp, of providing interesting challenges in ensuring that the language really is easily portable due to their difference from the others.)</li> <li>Focus on simplicity and portability: it should purely be an algorithm representation format, without input/output capabilities. It is for implementing the algorithms of a program once, and having it be available in various languages. Things such as input/output and native calls should be provided as an API specification for the StageL source file: at the top of the file, it should declare all the implementation-dependent functions that it requires; these would then be provided separately by the programmer and/or by a set of functions provided with StageL for each target language. (This was loosened in practice and a standard library with some basic I/O is required.)</li> <li>All input/output to/from the language is as functions. All code must be in a function, with declared parameters, parameter types, variables needed, and return type. (The expense of the simple type system is that changing return values would break functions' API, since "out" parameters and/or pointers would not be available, but this should allow the code to be simple and readable, which is a priority for this language.)</li> <li>Output files should retain the structure and comments of the input files, thereby retaining readability as far as the target language permits.</li> <li>All behavior should be specified. Ambiguous programs should be impossible to write knowing the specification, and (as far as possible) the meaning of a program should be obvious and unambiguous <em>without</em> the language specification. Programs that do not match the specification exactly should be entirely rejected, rather than produce warnings or having a best guess of its meaning made.</li> </ul> <h2 id="Actual_results_of_the_design_goals">Actual results of the design goals</h2> <p>It works satisfactorily. It's pretty portable, I think. Things aren't fully specified because it transpiles to native constructs that behave differently between target languages. This could be resolved by implementing a VM or something in each target language, but that's a pain, so this is good enough for what this is for. Low-level facilities aren't really available yet. I guess they can be added as additional builtin routines. One option might be implementing a WebAssembly VM or something that is available implemented purely in StageL, but can be accessed natively if available to be faster.</p> <h2 id="Syntax">Syntax</h2> <p>Lines are separated by 0x0A. Each line consists of printable ASCII text a—z 0–9 slash, spaces, &lt;, &gt;, [, ], (, ), and } (but not {, except in string literals or comments). Within a line is a sequence of space-delimited words. Semantic levels are denoted by four spaces' indentation. The first word in a line is a command. Comments (started with #) and string literals can contain any printable ASCII (although string literals can't contain ' because it's used to indicate them; this could probably be fixed easily enough if I want to (TODO)). Identifiers can contain ASCII text a-z A-Z and 0-9 (but 0-9 may not be the first character, and code that relies on case sensitivity or insensitivity by having ident references differ only in case or having two idents that differ only in case is a (possibly un-notified-about) error (these are not technical restrictions; they're just required in the interest of portability)).</p> <p>There are several built-in commands in the core language, which is in stagel.js or whatever your output language is. There are also commands from the standard library, which is in stager.js.</p> <h3 id="Gotchas">Gotchas</h3> <ul> <li>Whitespace is (usually) significant. There isn't a 1:1 correspondence between valid source files and the parsed code, though, I don't think. Indentation must be with 4 spaces.</li> <li>Unexpected byte values in code files aren't allowed and should cause the parser to die; strings or comments containing byte values other than printable ASCII are an error.</li> <li>The value of a variable before it has been set in a given block is undefined; don't access it until it has been set (and don't rely on variable hoisting). That's an error, but there isn't anything in place to detect it.</li> <li>Argument lists can contain references to any type.</li> <li>Strings are not intended to be used for data interchange; rather they're for process-internal use for making semantically clear array mappings and such — they don't have any Unicode or binary-safe support, or even full printable ASCII support (' isn't supported in strings) for that matter. An integer array representing bytes is preferred for when you need to actually keep more careful track of data.</li> <li>Routine parameter types can be generic, string, number, bool, or array. Void is not an allowed parameter type (although I'm not sure what that would actually mean).</li> <li>Routine return types can be string, number, bool, array, or void. Generic return type is not allowed, separate routines for each return type desired must be used instead.</li> <li>Routines can be composed in argument lists, but only one inner routine per argument list; the inner routine must be the last argument. Using temporary variables is needed in other cases. For example: <code>set n/foo add 2 mod 7 5</code> sets n/foo to 4, but you can't do <code>set n/foo add mod 7 5 2</code> or <code>set n/foo add mod 7 5 mod 7 5</code> are errors, although they won't necessarily give an error (they will be interpreted as add(mod(7,5,2)) and add(mod(7,5,mod(7,5))) respectively, with the third argument to mod probably being discarded by the implementation).</li> <li>Some commands (e.g. new, return) can't handle routines in argument lists; this <strong>should</strong> die with an error, but no promises.</li> <li>Referencing or assigning to a variable that has not been assigned is an error, but there isn't anything in place to detect it.</li> <li>Code like:<pre><code>r/s/fbSwitcher n/num
    if eq 0 mod n/num 15
        return 'Buzz'</code></pre> is an error, because if the if statement is not true, the function will exit without returning (basically being a void). There's nothing in place to detect this, though. This example is from <code>cli/tests/stagel/js/routine-fbSwitcher-return-type/in/in.stagel</code>, which should perhaps be rewritten to not have this fault (ideally, a check for this problem would be added to the transpiler or generated code, but I can't be bothered right now). Likewise, routines with a return type but no return statement are an error without any detection.</li> <li>In assignments, calls, etc. where routines can be composed, they usually have to be evaluated strictly left to right. Thus, <code>set n/a sub len s/b 1</code> is an error (I don't think there is any detection for this): it will be interpreted as <code>set(n/a, sub(len(s/b, 1)))</code> when what is desired is <code>set(n/a, sub(len(s/b), 1))</code>. It should instead either use the inline-arglist-end marker <code>}</code> and be written as <code>set n/a sub len s/b } 1</code>, or be written as two statements: first <code>set n/a len s/b</code>, then <code>set n/a sub n/a 1</code>.</li> <li>Type constraints are generally only enforced when values are returned or given as parameters (in which case they are checked by code automatically inserted into the routine called during transpilation). Thus, for instance, you can assign the wrong datatype to a variable without it showing an error, and it will only die when it gets returned or passed to another routine.</li> <li>Array literals can (probably) only be used with the <code>set</code> command. For other things, make a temp value, assign the array literal to it, and then use the temp value in its place.</li> <li>Whitespace requirements apply to lines where the entire line is a comment, too.</li> <li>Comments have to be on their own lines.</li> <li>What's wrong with this code? <pre><code>    while lt 8 len an/res
                set an/res push [ 0 ] an/res
	</code></pre> The array bracket type doesn't match the content type: [ is for strings, while ( is for numbers.</li> <li><code><pre>set an/remainderArr anSubset an/in -5 -1 # last 4 characters</pre></code> breaks; the comment needs to be on a separate line.</li> <li>Code like <code><pre>set as/data append as/data [ s/key s/val ]</pre></code> is an error: array literals can't contain variables in their definitions.</li> </ul> <h3 id="Example">Example</h3> <code> r/s/fbSwitcher n/num if eq 0 mod n/num 15 return 'FizzBuzz' # just a literal sequence of bytes. Everything should be binary safe. 0x could be used to return data, too. 0x = data, not numbers, in StageL. # Comment if eq 0 mod n/num 5 return 'Buzz' # Comment 2 # Comment 3 if # Could also write it like this, with the condition on another line eq 0 mod n/num 3 return 'Fizz' # Comment 4 r/s/fizzBuzz # A string is an array of 8-bit bytes. # return-assert -n # the output should be non-empty. new n/counter 1 until eq n/counter 100 set n/counter add n/counter 1 new s/temp '' set s/temp r/s/fbSwitcher n/counter return s/temp </code> <h2 id="Special_syntaxes">Special syntaxes</h2> <p>For loops aren't available because they add complexity to the transpiler.</p> <dl> <dt>if</dt><dd>conditional: bool, block</dd> <dt>else</dt><dd>if, bool, block, (elif, bool, block)..., else, block</dd> <dt>elif</dt><dd>if, bool, block, (elif, bool, block)...</dd> <dt>while</dt><dd>while, bool, block</dd> <dt>until</dt><dd>until, bool, block</dd> <dt>new</dt><dd>new ident</dd> <dt>set</dt><dd>set ident value</dd> <dt>}</dt><dd>End parameter list without new line</dd> </dl> <h2 id="Scope">Scope</h2> <p>Values are available until the end of the block they are in. Whether they propagate outside of the block is undefined. Accessing them outside the block, or before the line they are defined, is an error, but there isn't anything in place to detect it. Use routine return values to move things around.</p> <h2 id="Errors">Errors</h2> <p>When an error is encountered, it will produce a message somehow. Execution of the program may stop. Otherwise, behavior is undefined. For instance, in JavaScript in browser it will send a console log message. In bash, it will call "die" from ember-shared.</p> <h2 id="Types_and_basic_commands_for_them">Types and basic commands for them</h2> <p>Routines that have type "v" are void. These are all the primitive commands that are implemented natively for each language. Other commands are included in StageR library of useful commands. Type "g" is generic, can only be used as a parameter for a routine. It indicates it can be either string, int, or bool. Type "ga", can also only be used as a parameter, is a generic array, which is either an array of ints, an array of strings, or an array of bools (an array can't contain a mixture), and all arrays passed to a routine that accepts generic-array parameters must be the same type (e.g. all int arrays). Type "gi" (generic item(s)) is like "ga" but can also be a single bool, int, or string.</p> <h3 id="b:_Booleans">b: Booleans</h3> <p>Can be True or false. Can not be undefined (initialized to false).</p> <dl> <dt>r/b/and n/a n/b</dt><dd>Returns bool a and b</dd> <dt>r/b/or n/a n/b</dt><dd>Returns bool a or b</dd> <dt>r/b/not n/a n/b</dt><dd>Returns bool a not b</dd> </dl> <h3 id="n:_Numbers_.28integer_only.29">n: Numbers (integer only)</h3> <p>Can be 0, or positive integer. Can not be undefined (initialized to 0). Currently is restricted to 32-bit signed (-2,147,483,648 to 2,147,483,647), but may be increased if more are needed.</p> <dl> <dt>r/n/add b/a b/b</dt><dd>Returns the sum of two numbers a and b</dd> <dt>r/n/sub b/a b/b</dt><dd>Returns the difference of two numbers a and b</dd> <dt>r/n/mod b/a b/b</dt><dd>Returns the modulo of two numbers a and b</dd> </dl> <h3 id="s:_Strings">s: Strings</h3> <p>A sequence of characters: can be ASCII printable characters or space. No newlines or control characters, I guess. The string support isn't supposed to be very capable, just easy to implement lowest-common-denominator between target languages for making labels for stuff and whatever. For actual data, use arrays of integers.</p> <dl> <dt>r/s/substring s/input n/start n/end</dt><dd>Give the characters from start to end (indices as bytes (characters — no Unicode support here, sorry) into input)</dd> <dt>r/s/cat s/a s/b</dt><dd>Concatenates a and b</dd> <dt>r/n/len s/input</dt><dd>Gives the number of bytes of input.</dd> </dl> <h3 id="Basic_type_utility_routines">Basic type utility routines</h3> <p>These operate on str/int/bool.</p> <dt>r/s/strFrom g/input</dt><dd>Give string with contents.</dd> <h3 id="Array_utility_routines">Array utility routines</h3> <p>A set of routines for managing arrays apply to any of the three array types (except the typed subset ones). Note that the push/append/prepend functions may not check that the type of the item being added to the array matches the array type; calling it with mismatched parameters is an error but may not be reported. </p><dl> <dt>r/a/copy gi/a gi/b</dt><dd>Set a to have the contents of b.</dd> <dt>r/a/push ga/array gi/value</dt><dd>Append the value to array. Same as r/an/append</dd> <dt>r/a/append ga/array gi/value</dt><dd>Append the value or array of values to array.</dd> <dt>r/a/prepend ga/array gi/value</dt><dd>Prepend the value or array of values to array.</dd> <dt>r/n/pop ga/array</dt><dd>Get the last element of the array.</dd> <dt>r/n/shift ga/array</dt><dd>Get the first element of the array.</dd> <dt>r/a(b,n,s)/a(b,n,s)Pop a(b,n,s)/array</dt><dd>Return the array without its last element.</dd> <dt>r/a(b,n,s)/a(b,n,s)Shift a(b,n,s)/array</dt><dd>Return the array without its first element.</dd> <dt>r/n/get ga/array n/index</dt><dd>Return the value of the array at index</dd> <dt>r/n/count ga/array</dt><dd>Return the number of elements in the array (also the maximum index; sparse arrays are not supported)</dd> <dt>r/v/setElement ga/array n/index gi/value</dt><dd>Set the indexth element of the array (0-indexed) to value. If value is an array, it will replace the following elements to its length.</dd> <dt>r/b/contains ga/array g/value</dt><dd>Returns "true" if the array contains the specified value.</dd> <dt>r/a(b,n,s)/a(b,n,s)Subset a(b,n,s)/array n/start n/end</dt><dd>Return the subset of the array from start index to end.</dd> </dl> <h3 id="an:_Number_Arrays">an: Number Arrays</h3> <p>A sequence of numbers. Starts with a ( and ends with a ). E.g. <code>( 5 6 )</code>.</p> <h3 id="ab:_Boolean_Arrays">ab: Boolean Arrays</h3> <p>A sequence of bools. Starts with a &lt; and ends with a &gt;. E.g. <code>&lt; false true &gt;</code>.</p> <h3 id="as:_String_Arrays">as: String Arrays</h3> <p>A sequence of strings. Starts with a [ and ends with a ]. E.g. <code>[ "foo" "bar" ]</code>.</p> <h2 id="StageR_commands">StageR commands</h2> <p>These commands are implemented in StageL by composing the basic commands for easy portability. (Sorry, not really documented yet; look in implementation/portable/*.stagel to see what's available.)</p> <h3 id="Booleans">Booleans</h3> <h3 id="Numbers">Numbers</h3> <dl> <dt>r/n/add n/a n/b</dt><dd>Returns the sum of two numbers a and b</dd> <dt>r/n/sub n/a n/b</dt><dd>Returns the difference of two numbers a and b</dd> <dt>r/n/mul n/a n/b</dt><dd>Returns the multiplication of two numbers a and b</dd> <dt>r/n/mod n/a n/b</dt><dd>Returns the modulo of two numbers a and b</dd> </dl> <h3 id="Strings">Strings</h3> <dl> <dt>r/s/strCharAtPos s/input n/index</dt><dd>Give the character at index bytes (=characters — no Unicode support here, sorry) into input</dd> </dl> <h3 id="Arrays">Arrays</h3> </main> </body> </html>