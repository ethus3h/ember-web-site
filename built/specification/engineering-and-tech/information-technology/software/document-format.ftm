<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <link href="/simple.css" rel="stylesheet" type="text/css"> <meta content="Ember" name="author"> <meta content="width=device-width,height=device-height,user-scalable=yes" name="viewport"> <meta name="generator" content="Futuramerlin Web Toolkit 2.3.98"> <title>Ember</title> </head> <body> <input class="nav-trigger" id="nav-trigger" type="checkbox"> <label for="nav-trigger">&nbsp;</label> <nav> <p class="logo"> <a class="nodecorate logolink" href="/">ember</a> </p> <ul> <li>Navigation:</li> <li class="nav-item nav-item-inactive"> <a href="/">Home</a> </li> <li class="nav-item nav-item-inactive"> <a href="/news">News</a> </li> <li class="nav-item nav-item-inactive"> <a href="/ancillary/ready-to-use.htm">Software</a> </li> <li class="nav-item nav-item-inactive"> <a href="/components.htm">Primary project components</a> </li> <li class="nav-item nav-item-inactive"> <a href="/people">People</a> </li> </ul> <a href="#">&#x1F51D;&#xFE0E;</a> </nav> <main> @t Information Technology Software Environment: Native document format <p class="breadcrumbs">Page location: <span><a href="/components.htm">Core project components</a></span> <span><a href="/specification">Specification</a></span> <span><a href="/specification/engineering-and-tech">Engineering and Technology</a></span> <span><a href="/specification/engineering-and-tech/information-technology">Information technology</a></span> <span><a href="/specification/engineering-and-tech/information-technology/software">Information Technology Software Environment</a></span> </p><nav id="toc"><h2>Table of Contents</h2> <ol><li><a href="#Objective">Objective</a></li> <li><a href="#Language_profiles">Language profiles</a></li> <li><a href="#Dcs">Dcs</a> <ol><li><a href="#Reading_DcData.csv">Reading DcData.csv</a></li> <li><a href="#Notes_on_specific_Dcs">Notes on specific Dcs</a> <ol><li><a href="#Dcs_241.E2.80.93245:_Mode_indicators">Dcs 241–245: Mode indicators</a></li> <li><a href="#Dcs_246.E2.80.93255:_Source_formatting_control">Dcs 246–255: Source formatting control</a></li> </ol></li> </ol></li> <li><a href="#Document_formats">Document formats</a> <ol><li><a href="#EITE_Language_as_Unicode_Private_Use_Characters_.28dcBasenb.29.2C_.dcbnb.utf8.txt_.28assuming_UTF-8_representation_of_Unicode.29">EITE Language as Unicode Private Use Characters (dcBasenb), .dcbnb.utf8.txt (assuming UTF-8 representation of Unicode)</a></li> <li><a href="#EITE_Language_source_files_.28ELS.29.2C_.els">EITE Language source files (ELS), .els</a></li> <li><a href="#EITE_Language_in_ASCII_documents_.28ELAD.29.2C_.elad">EITE Language in ASCII documents (ELAD), .elad</a></li> <li><a href="#EITE_Language_sequence_files_.28ELQ.29.2C_.elq">EITE Language sequence files (ELQ), .elq</a></li> <li><a href="#Documented_EITE_Language_sequence_files_.28DELQ.29.2C_.delq">Documented EITE Language sequence files (DELQ), .delq</a></li> <li><a href="#Source-Documented_EITE_Language_sequence_files_.28SELQ.29.2C_.selq">Source-Documented EITE Language sequence files (SELQ), .selq</a></li> <li><a href="#EITE_Record_Documents_.28ERD.29.2C_.erd">EITE Record Documents (ERD), .erd</a></li> </ol></li> <li><a href="#Structures_in_the_EITE_Language">Structures in the EITE Language</a></li> <li><a href="#Basic_implementation_process_flow">Basic implementation process flow</a></li> </ol> </nav> <h2 id="Objective">Objective</h2> <p>Develop a machine-readable language that can be used as an equivalent representation of documents represented as sequences of Dcs, for easier reading and editing by humans (using an ordinary text editor and conversion tool). It should also be able to be implemented using and transpiled into StageL.</p> <h2 id="Language_profiles">Language profiles</h2> <p>EITE Language programs may optionally declare a non-default language profile to use: Core, Basic, and Dangerous (the default is "Standard"). Core and Basic both restrict the program to a subset of the language. The Basic language interpreter is written using the Core subset of the language, and provides useful shortcuts to use in the development of the interpreter for the Standard profile. The Default language interpreter is written using the Basic subset of the language, which will correspond to StageL. The Dangerous profile allows using language features which are probably a bad idea to use, but may be needed in some cases.</p> <h2 id="Dcs">Dcs</h2> <p>The core unit of the EITE Language is the Dc (Document Component). The defined Dcs are listed in DcData.csv. An EITE Language document is a list of Dcs, and a file is considered <em>structurally valid</em> if it can be interpreted as such. A Dc can have a syntactical pattern that it can require if it is to be meaningful. For example, a marker to <em>begin</em> a section of a document might be required to have a matching <em>end</em> marker. A document is only <em>syntactically valid</em> if the usage of each Dc contained within it conforms to the Dc's defined syntax, even if the document is otherwise structurally valid.</p> <h3 id="Reading_DcData.csv">Reading DcData.csv</h3> <p>DcData.csv contains nine columns, each of which gives some information about a given Dc.</p> <p>From left to right, the columns are: ID, Name, Combining class, Bidirectional class, Simple case mapping, Type, Script, Details, and Description.</p> <p>The "ID" column specifies the number used to refer to a given Dc. Once an ID has been specified in a stable version, its meaning will not change in future versions.</p> <p>The "Name" column specifies an informative name for the Dc. The names may change in future versions if the current names seem suboptimal. They should not be relied on as unique or stable identifiers. If a name is prefixed with "!", then that Dc is deprecated. Names <em>should</em> be unique within any given version of DcData.csv, although errors in it could compromise that (it is not currently checked by a computer).</p> <p>"Combining class" column: See below.</p> <p>"Bidirectional class" column: See below.</p> <p>"Simple case mapping" column: This column contains the ID of the uppercase form of characters with the "Ll" type, and the ID of the lowercase form of characters with the "Lu" type.</p> <p>"Type" column: See below.</p> <p>The "Script" column indicates the script or other set to which the character belongs. Values needing further explanation include "Semantic", "DCE", "DCE sheets", "Noncharacters", "DCE versions", "Encapsulation", "EL Syntax", "EL Routines", and "EL Types".</p> <p>The "Details" column contains various additional information about characters, as a comma-separated list. <ul> <li>List entries beginning with "&gt;" are cross-references to related Dcs. List entries beginning with "&lt;" are decompositions.</li> <li>List entries beginning with "(" indicate the syntax (parameter type signatures) for EITE Language routines.</li> <li>List entries beginning with ":" indicate the required syntax for the given Dc, using a form similar to regular expressions: <ul> <li>a bracketed list of Dcs [] indicate a set of possible Dcs</li> <li>a bracketed list of Dcs with a ^ at the beginning indicates an inversion of the set</li> <li>+ indicates 1 or more of the preceding item</li> <li>a Dc ID in brackets with a colon before the closing brackets indicates any syntactically correct sequence of Dcs beginning with the enclosed Dc ID</li> <li>"~" represents the Dc the syntax of which is being defined</li> </ul> </li> </ul> The remaining list entries are aliases (alternate names for the characters, for ease of look-up).</p> <p>The "Description" column contains additional comments regarding the Dc.</p> <p>Three columns' contents are directly inherited from the Unicode Standard: Combining class (inherits Unicode's "Canonical_Combining_Class property"), Bidirectional class (inherits Unicode's "Bidi_Class" property), and Type (inherits Unicode's "General_Category" property). The "Simple case mapping" and "Script" columns should also be inherited from Unicode in some manner, but are not at present. For characters not included in Unicode, a reasonable value is chosen in the pattern of the values used by Unicode. If there are discrepancies between this value and Unicode's value for a given character that is in both sets, this should be reported as an error in the EITE Language standard. Unicode's values should take precedence.</p> <p>"Type" column values also extend the Unicode Standard's possible values with the "!Cx" category, denoting characters that do not fit neatly into Unicode's existing categories.</p> <h3 id="Notes_on_specific_Dcs">Notes on specific Dcs</h3> <h4 id="Dcs_241.E2.80.93245:_Mode_indicators">Dcs 241–245: Mode indicators</h4> <p>Inclusion of the mode indicators in documents is <em>optional</em>. The selected mode expresses information about the document's expected execution environment. These modes are shortcuts that set up the environment in advance so that the document does not need to contain specific code to set up these contexts. This lets the documents making use of these indicators be more concise and readable.</p> <h4 id="Dcs_246.E2.80.93255:_Source_formatting_control">Dcs 246–255: Source formatting control</h4> <p>Dcs 246 through 255 control the formatting of the ELS format version of a document.</p> <h2 id="Document_formats">Document formats</h2> <p>There are seven file formats defined by this specification. Six of them (dcBasenb, ELS, ELAD, ELQ, DELQ, and SELQ) are general-use formats, while the seventh (ERD, not yet specified) is a special-purpose format with a subset of the other formats' capabilities. DcBasenb and ELS are the primary formats, while ELAD, ELQ, DELQ, and SELQ are intended as an intermediate, more-readable format, and are not intended for information interchange (they are much larger than the other formats for a given document, in general).</p> <p> Implementations should be able to render a document exactly (bit-for-bit) as determined by earlier versions of the specification. A syntax should be provided to indicate the version of the specification a given Dc, region of Dcs, or document should be displayed using (exactly, not just semantically), although Dcs have not been created for this purpose yet.</p> <p>There is a one-to-one correspondence within a given version of the specification and implementation between normalized dcBasenb, ELS, ELAD, ELQ, DELQ, and SELQ files (for any given document in one of those formats, there is only one way to represent it in the other formats), but not for ERD files (because ERD files can only represent a subset of EITE Language documents). That means that documents can be losslessly round-trip-converted between those six formats. <em>However</em>, when converting from an ELS file, if it does not have a version specified, its behavior may change due to changes in the mapping between source code and Dc IDs. Source form should be able to represent syntactically invalid documents unambiguously. Whether structurally invalid source-form documents should be able to be represented as structurally valid Dc sequences is debatable.</p> <p>DcBasenb files are a specific interpretation of the private-use-area characters in Unicode text.</p> <p>ELAD, ELS, ELQ, DELQ, and SELQ files are subsets of ASCII text files, with lines delimited by 0x0A (line feed). Bytes 0x00 through 0x09, 0x0B through 0x1F, and 0x7F through 0xFF (all ranges inclusive) are disallowed. Files must end with 0x0A. This may later be changed to use UTF-8.</p> <p>A less strictly specified format has an implementation available: "integerList" (.dcil), which is a list of ASCII digits representing Dcs, with each Dc followed by a space (including the last one), and no trailing newline or comments.</p> <p>At the end of each format's summary (except for EMR), a simple "Hello, World!" document is given in the format.</p> <h3 id="EITE_Language_as_Unicode_Private_Use_Characters_.28dcBasenb.29.2C_.dcbnb.utf8.txt_.28assuming_UTF-8_representation_of_Unicode.29">EITE Language as Unicode Private Use Characters (dcBasenb), .dcbnb.utf8.txt (assuming UTF-8 representation of Unicode)</h3> <p>This format uses Unicode characters for Dcs that have losslessly roundtrippable Unicode equivalents, while representing Dcs that are not mappable to Unicode as sequences of Unicode private use area characters. Note that there are multiple possible ways a given Dc or sequence of Dcs can be represented as private use area characters, so only the normalized form (the form output by the implementation) is strictly roundtrippable to Dcs, and only for a given version of the specification and implementation (incidentally, the implementation for importing them does not verify that the normalized form was used and warn otherwise, but it should).</p> <pre><code>Hello, World!</code></pre> <h3 id="EITE_Language_source_files_.28ELS.29.2C_.els">EITE Language source files (ELS), .els</h3> <p>EITE Language source files are a programming language–inspired representation of EITE Language documents. It is the most readable of the formats, but also (along with SELQ, which is defined in terms of it) the most technically complex.</p> <pre><code>dc:
Hello, World!</code></pre> <p>or more idiomatically (but not the exact equivalent of the others in terms of the Dcs used),</p> <pre><code>say 'Hello, World!'</code></pre> <p>which would be</p> <pre><code>256 258 260 262 # . . . .
264 263 57 86 # . . H e
93 93 96 30 # l l o ,
18 72 96 99 # . W o r
93 85 19 261 # l d ! .
259 # .</code></pre> <p>in Dcs, or even more simply the <code>say</code> could be omitted since literals are printed by default: <code>'Hello, World!'</code>.</p> <h3 id="EITE_Language_in_ASCII_documents_.28ELAD.29.2C_.elad">EITE Language in ASCII documents (ELAD), .elad</h3> <p>EITE Language in ASCII documents are a list of Dcs. The Dcs mappable to the permitted ASCII characters are represented by those ASCII characters, with the exception of 0x40 "<code>@</code>" (Dc 1). All other Dcs are represented by "<code>@</code>" followed by the integer Dc ID followed by a space, such that, for instance, "<code>@</code>" would be represented as "<code>@1 </code>".</p> <pre><code>Hello, World!</code></pre> <h3 id="EITE_Language_sequence_files_.28ELQ.29.2C_.elq">EITE Language sequence files (ELQ), .elq</h3> <p>A list of Dc numbers. Four Dcs are given per line, separated by spaces.</p> <pre><code>57 86 93 93
96 30 18 72
96 99 93 85
19</code></pre> <h3 id="Documented_EITE_Language_sequence_files_.28DELQ.29.2C_.delq">Documented EITE Language sequence files (DELQ), .delq</h3> <p>A variant of the EMS format for easier reading: after each line, the printable ASCII equivalent of each Dc is given following <code>0x202320</code>, each separated from the next by a space. If there is no printable ASCII equivalent, or the character is a space, "." is used instead.</p> <pre><code>57 86 93 93 # H e l l
96 30 18 72 # o , . W
96 99 93 85 # o r l d
19 # !</code></pre> <h3 id="Source-Documented_EITE_Language_sequence_files_.28SELQ.29.2C_.selq">Source-Documented EITE Language sequence files (SELQ), .selq</h3> <p>A variant of the ELQ and ELS formats for easier reading: the ELS source version is given in a comment in the style of the DELQ format, but the number of Dcs on each line is determined by the source lines to which they correspond.</p> <pre><code># dc:
57 86 93 93 96 96 30 18 72 96 99 93 85 19 #     Hello, World!</code></pre> <h3 id="EITE_Record_Documents_.28ERD.29.2C_.erd">EITE Record Documents (ERD), .erd</h3> <p>This is a special format in the "Structured" mode used for structured record storage in EITE. It is not yet defined, but will most likely be a subset of one of the other formats.</p> <h2 id="Structures_in_the_EITE_Language">Structures in the EITE Language</h2> <p>The EITE Language uses the following main types of entity to represent information: </p><dl> <dt>Type</dt><dd>Types are templates describing the structure of objects. They are known as prototypes or classes in most programming languages, depending on whether objects described by them inherit changes to the types made after the object was created. (Objects can be used as types by casting.) Type names begin with a capital letter when in source form.</dd> <dt>Object</dt><dd>An object is an entity that conforms to a given type (an <em>instance</em> of that type). The most general type is <em>object</em>, and there is no need for an object to conform to any other type. Whether the type it inherits from is treated as a class or a prototype should be able to be specified.</dd> <dt>Block</dt><dd>A block is a group of statements.</dd> <dt>Project</dt><dd>A project is a single document, and if relevant, any other documents maintained as part of that document.</dd> <dt>Module</dt><dd>A module is one or more Library-mode documents that have a package name for addressing the things they provide.</dd> <dt>List</dt><dd>A list is an ordered list of objects.</dd> <dt>String</dt><dd>A string is a list of Dcs. Because all Dcs can be used in strings, any data type can be cast to a string, and all data types internally <em>are</em> strings of Dcs.</dd> <dt>Routine</dt><dd>A routine is a set of instructions for a computer to follow as part of the process of interpreting a document. Similar concepts are known as functions or subroutines in most programming languages, or as methods when used within objects. Routines have an associated structure that indicates what parameters may be passed to it.</dd> <dt>Operator</dt><dd>An operator is a short notation or syntax pattern for some common routines.</dd> <dt>Identifier</dt><dd>An identifier is a name for an object.</dd> <dt>Structure</dt><dd>A structure is the definition of what the structure is that an entity can have, similar to type definitions or type signatures in some programming languages. A type can contain named Structures without any values for defining an interface.</dd> <dt>Statement</dt><dd>A statement is a logical line of a document. It can be an invocation of a routine, or a declaration of an entity's structure or value.</dd> </dl> <p></p> <h2 id="Basic_implementation_process_flow">Basic implementation process flow</h2> <p>This diagram shows conceptually how data flows at a high level in the process of running an EITE document using an interpreter (a compile-then-run system would use different data flows, but the overall effect would be equivalent). The non-bracketed elements represent programmed processes. The bracketed elements represent data structures. A circle ○ represents data storage persists for the lifetime of the document being open or being executed (not necessarily in RAM: for a long-running background task, like a periodic mail fetcher, this data could be moved to disk or the cloud if useful to free up local memory). Other data structures can be buffered/streaming FIFOs that discard input as it becomes unneccesary. The arrows represent data flows into and out of data storage or the system. This diagram assumes a Dc sequence as input; other forms of input would need a separate conversion/interpretation step for this.</p> <pre>         External I/O: document source ──────────────╮
               (as Dc sequence)                      │
                                                     ↓
   [○ Document execution state] ╮    ╭ [○ Document as Dc sequence] ←╮
                ↑               ↓    ↓                              │
                ╰───── Document execution loop:  ───────────────────╯
  Other External I/O ← iterates over tokens (Dcs)
                                   ↓
                              Renderer: converts and
                              and writes to renderer
                              buffer visible document
                              elements
                                     ↓
                              ⎡ Renderer buffer: holds     ⎤
                              ⎢ representation of document ⎥
                              ⎢ in the format desired for  ⎥
External I/O: render target ← ⎢ output (terminal text for  ⎥
(e.g. terminal or browser)    ⎢ a CLI, HTML for a browser, ⎥
                              ⎢ bitmap for a raster        ⎥
                              ⎢ monitor or HTML Canvas,    ⎥
                              ⎢ other formats for export,  ⎥
                              ⎣ etc.)                      ⎦</pre> </main> </body> </html>