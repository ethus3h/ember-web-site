<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <link href="/simple.css" rel="stylesheet" type="text/css"> <meta content="Ember" name="author"> <meta content="width=device-width,height=device-height,user-scalable=yes" name="viewport"> <title>Ember Information Technology Environment</title> </head> <body> <main>
<h1>Ember Information Technology Environment</h1>
<h2>Information Technology Software Environment: Introduction and overview</h2>


<h3>Introduction</h3>
    <h4>Abstract</h4>
        <p>This section of the Ember project specification introduces and documents the Ember computing environment, a project to develop a document-centric computing environment and data format. It is a proposal, design, specification, and (as of now prototype) implementation for an information technology system. The computing environment would be comprised of a centralized append-only information store, a computer operating system user interface integrated with that information store, and related specifications. The computing environment proposed here is distinct from existing technologies in that it attempts to provide superior flexibility by representing all information and documents it uses or processes (including its own software) as strings of text in a Unicode-based character encoding extended for this purpose. This is a work-in-progress draft, and everything here is subject to change and is not presently suited for implementation.</p>

    <h4>The Problem</h4>
        <p>Existing information technology systems have various unnecessary limitations. In addition, many existing information technology systems are not libre software. "Libre" refers to the ethical principle of freedom of knowledge, whereby knowledge is provided with the legal protection of rights such as modification and redistribution. (For specifics on this project's goals and strategies in libre licensing, see the "Licensing" section below.) This results in wasted effort on developing redundant proprietary technologies (for instance, multiple non-interoperable word processing apps), regressions in standards of living caused by the unavailability of proprietary systems (for instance, not being able to use the features of a previous version of a word processing app the more recent versions of which have had some capabilities removed), and the incalculable loss of shared cultural heritage through inconsistent or nonexistent archival practices (and in many cases active hostility towards historical preservation, especially in the interest of short-term personal economic gain) (for instance, the loss of many historic films and television series to neglect or deliberate destruction).</p>
        <p>These problems are not hypothetical. They are very real and ongoing problems, and are actively causing very real and ongoing harm.</p>
        <p>While current computing hardware, and many other processes and aspects of society, have many of the same and similar problems as the problems in software that this subproject aims to address, this section only focuses on software. Other parts of the Ember project deal with computing hardware, industry and industrial designs, and social organization, so these areas are not addressed here.</p>
        <p>Information technology systems are not connected to each other effectively. While standard protocols for some types of data interchange are available, a single integrated IT system for building documents that leverage the full array of diverse types of information that can be represented using IT does not yet exist. In addition, current IT systems do not effectively orient their users and give them a sense of groundedness in regard to what they are doing.</p>

        <h5>Existing work towards solving this problem</h5>
            <p>Many existing projects address various aspects of the issues this project addresses. None seems to cohesively aim to integrate these aspects into a comprehensive libre framework and model implementation, though, driving the need for this project. For an annotated list of related projects and inspirations to this project, see the "Related projects and inspirations" section of the bibliography at the end of this document.</p>

<h3>General approach</h3>
    <p>This project should aim to systematically support the libre development and distribution as best as possible of an innovative information technology environment.</p>

    <h4>Current project status</h4>
        <p>"Ember Information Technology Environment" is the current name of this project.</p>
        <p>This project is a part of "Ember", a project to develop and facilitate collaboration on a specification, a library, and a model community, to serve as resources and infrastructure for innovative communities. More information about Ember is available at the Web site for the project, <a href="http://futuramerlin.com/">http://futuramerlin.com/</a>.</p>
        <p>The primary components comprising the project are currently unfinished, but a variety of software maintained to facilitate the development of the project is available.</p>
        <p>A preliminary implementation of the computerized document representation format proposed herein is under development. An interpreter, several format converters, preliminary editing tool, and test suite and runner have been developed so far, as has a demonstration Web browser extension that allows authoring text in Web site text fields using the editing tool and automatically rendering sections of text in the document format embedded in Web pages. Continued work on the interpreter and implementation of the computing environment itself remain.</p>
        <p>The main functional output of the project so far has been the successful development of three well-tested, partially completed software applications that are currently used to facilitate the further development of the project. The first of these is a portable, easy-to-write, transpiled programming language for portable rapid application prototyping being used to develop the prototype implementation. The second of these is a static Web site generator, which is used to build the project's Web site (it includes working features for theming using CSS, with some included themes, automatic blog pagination, and discography Web site generation for musicians). The third of these is a suite of tools for working with file version tracking, document archiving, and data storage and distribution. It is currently in use for storing and managing the more than eleven million files and forty version control repositories used now for this proposal's parent project, as well as the structured archiving of more than eighteen million additional documents outside of the project.</p>

<h3>Intended outcomes</h3>
<ul>
    <li>The end goal of this work is the development of a completed, stable software environment used for developing the project, consisting of:
        <ul>
            <li>Specifications</li>
            <li>Information technology environment software implementation</li>
            <li>The cloud computing infrastructure should use a decentralized, asynchronously resolving append-only data store, similar to blockchains, to ensure the preservation and longevity of data stored using it as best as possible.</li>
        </ul>
    </li>
</ul>
</ul>


<h3>Development tasks and process</h3>
<ul>
    <li>Develop, write, test, and document specifications
        <ul>
            <li>Information technology information and specifications, without external (non-libre) dependencies (enough information should be included to enable full construction of all technologies starting from nature, without any existing knowledge or technology/machinery; this should be <em>tested</em>)</li>
        </ul>
    </li>
    </ul>
    <li>Continue development of support software</li>

    <li>Develop software for information technology environment (EITE)
        <ul>
            <li>Provide and implement StageL inside EITE</li>
            <li>UI widgets</li>
            <li>Implement simple document editor in EITE</li>
            <li>Other EITE development tasks: networking, data storage and distribution, etc.</li>
            <li>Add C target to StageL</li>
            <li>Benchmark JavaScript implementation versus C→WebAssembly, out of curiosity. WASM would require clang in the toolchain, which wouldn't be ideal until clang can be run on non-WASM EITE, but anyway...</li>
            <li>Support WebAssembly in EITE</li>
            <li>Get text rendering and raster output implemented in EITE</li>
            <li>Complex text rendering support</li>
            <li>An alternative strategy could omit implementing the technology, and only focusing on developing the specification, although that strategy would risk increasing the problems the project is intended to fix (by providing existing IT companies with the project’s technological innovations, but not having a free/libre implementation of them to prevent companies using distorted clones of the idea to further their proprietary goals and vendor lock-in).</li>
        </ul>
    </li>
</ul>
</ul>


<h3>Overview and introduction</h3>
    <h4>Components of the project</h4>
        <p>The computing environment will consist of the following components:</p>
        <ul>
            <li>Development principles, describing the process to use for creating the computing environment</li>
            <li>Data format and its representations
                <ul>
                    <li>Specification</li>
                    <li>Reference implementation</li>
                </ul>
            </li>
            </ul>
            <li>Data storage system and infrastructure: mechanism for storing append-only set of records, each comprising a unique ID paired with a node document</li>

            <li>Software system, including:
            <ul>
                <li>Client component</li>
                <li>Server components, including:
                    <ul>
                        <li>Public-facing API</li>
                        <li>Search engine</li>
                        <li>Storage backend</li>
                    </ul>
                </li>
            </ul>
            </ul></li>

        </ul>
    <h4>Premise</h4>
        <p>Current computerized information technology systems do not live up to their potential. By developing tools to allow blending media types together, new opportunities arise in the use of information technology systems, including in structured data and the arts. An append-only decentralized archive of a community’s knowledge gives many advantages in usability, accessibility, and preservation.</p>
    <h4>Goals of the project</h4>
        <ul>
            <li>Proposing, prototyping, and developing a new form of computerized information technology system</li>
            <li>Basing that system on the potential of such systems, rather than mimicing the roles and restrictions of analog media</li>
            <li>Part of a project to develop tools and resources to make it easier to experiment with changes to society and technology in local communities</li>
        </ul>
    <h4>Why is this important?</h4>
        <p>Current computerized information technology systems do not fully explore and use the potential of the medium. Many popular computerized information technology systems are too complicated to understand well (this applies to hardware, too). Many popular computerized information technology systems cannot be relied on or trusted. Knowledge is not systematically protected for historical preservation. Current structured knowledge databases are unable to hold any types of information they are wanted to, as databases are restricted to an artificial subset of documents considered to be “text”. Current systems often are not easily flexible and customizable for end users.</p>
    <h4>Project strategies</h4>
        <ul>
            <li>Treating all media as sequences of units analogous to characters in text</li>
            <li>Allowing all types of media to coexist in a document, and avoiding restrictions on what can go where in a document</li>
            <li>Trying to ensure easy portability of software</li>
        </ul>
    <h4>Current status</h4>
        <p>The most practical product of this work is a transpiled programming language that can be easily converted to other languages. That way, you can write a program in one language, and have it run in many. A prototype document format interpreter is available, demonstrating unit-oriented document representation. A software library is available that provides APIs for running, importing, transforming, and exporting documents using this representation, and for data storage and Web interface access control. Documents can be exported as Unicode text, with non-Unicode contents stored using the Unicode private use area. A Web browser extension is available that can display text in Web pages represented using those Unicode extensions as the original document. A graphical tool for editing documents stored using this unit-oriented document representation is available, intended to facilitate the implementation of the next stages of the project. Documentation of the prototype is available, as is this document discussing the project.</p>
    <h4>Future goals and plans</h4>
        <p>This should serve as a demonstration of the potential of this type of information technology system. It should be extended to be usable as a practical computing environment. Unit-centric document representation allows structured data to represent information that is not supported by current database systems, and presents new opportunities for electronic media artists. As a computing environment, an append-only distributed data store should be provided, so that a community can use a network of computers running this software to share and track a shared machine-readable knowledge base of the community’s history and knowledge.</p>
        <p>All interactions with the computing environment should be continually recorded in the knowledge base, so that any computer in the network always has its data backed up, and (by using an append-only data store) be able to return to any previous state. All interactions with a computer could be recorded in real time, so that whenever you want you could see a previous state of your computer, so that you wouldn't have to wonder exactly how you got from point A to point B when working on a project; if you go back to it years later and wonder what you were thinking, you could actually see what you did as you were creating it. The user interface of the computing environment should be implemented using the same unit-oriented document format as the rest of the system, allowing it to be customized as desired to ensure it can serve each person in the manner they prefer.</p>
        <p>Having a community’s knowledge and history stored as structured, machine-readable data allows additional flexibility:
        <ul>
            <li>It can allow people to configure how they want to see information (such as ensuring the text size is always large enough).</li>
            <li>It can allow people to configure what information they want to be given (for instance, filtering out documents that have not been screened for being dangerous to people with photosensitive epilepsy).</li>
            <li>It ensures all knowledge in the system is preserved for future history.</li>
            <li>It can allow people to keep their information private, rather than having it slurped up for advertising.</li>
            <li>It can allow people to access, copy, back up, and conduct research using the information easily, rather than knowledge being locked up in commercial databases.</li>
        </ul></p>
    <h4>Summary</h4>
        <p>Current computerized information technology systems do not live up to their full potential. So, by developing tools to allow combining media types together, new opportunities arise in the use of information technology systems, including in structured data, the arts, and an append-only decentralized archive of a community's knowledge, giving many advantages in usability, accessibility, and preservation.</p>

 <h2>Information Technology Software Environment: Installation</h2>


<p>Using the ebuild to install the software through Portage is suggested. Simple installation (untested) in case Portage or the ebuild is not suitable for your system: <code>git clone --depth 1 https://github.com/ethus3h/ember-information-technology-environment; cd ember-information-technology-environment; make autodep; ./configure; make; sudo make install</code>. <code>curl</code> must be available already.</p>
<p>If you just build EITE without installing it, the built software will be placed in the "built/" folder. The structure of that folder corresponds to the /usr/share/eite/ folder when the software is installed. This is what is meant by the "EITE installation root" in this documentation.</p>

 <h2>Information Technology Software Environment: Design goals</h2>


<p>The goal of developing the EITE is to provide an information technology system that allows various types of data to be given a first-class role. The proposed system is a centralized but non-centralization-dependent append-only information store, a computer operating system integrated with that information store, and related specifications.</p>
<p>Web-based information technology companies such as Google, Amazon, and Facebook have a disproportionately large amount of power, have a disproportionately large role in how individuals are able to conduct their daily lives, and are single points of failure for a large portion of the modern lifestyle. These corporations are private institutions with little to no public oversight and control, despite having a large and visible role (perhaps even larger than any one government) in individuals’ lives. To begin to challenge that power structure, this semi-decentralized document-oriented computing platform should be developed that can integrate the abilities of traditional information technology systems into a single, cohesive system. Such a system should be free/libre software, and should be designed in such a way that it can adapt when needed to functioning as a fully decentralized, serverless system, transparently adjusting to the networking capabilities or lack thereof available to it on an ad-hoc basis. The existence of this project as a replacement would prevent single IT companies’ systems being single points of failure, and its distributed model would prevent it itself from being a single point of failure. Additionally, by being fully free/libre software, and by using a single system and data format for the full range of services, this proposal would reduce the dangers created by vendor lock-in, proprietary products, and incompatible IT systems.</p>
<p>An important basic principle of EITE is flexibility. It should allow the user do what they want in an elegant manner, without undue shenanigans, difficult workarounds, or unwanted assistance. It should accommodate various workflows, and be thoroughly customizable. Its default configuration should be simple and easy to use. User interfaces should abstract away technical complexities by default while remaining fully usable, while allowing access to those complexities if desired.</p>
<p>The system should use a single, libre, fully specified data format to store all types of information it processes, and development of the system should strive to ensure that a thorough selection of capabilities are provided out of the box using a consistent and customizable user interface, obviating the need for external apps (which often tend to be inconsistent in things such as internationalization and accessibility). The use of a single data format would allow, for instance, text, structured data, sound, and interactive media such as computer games to all be practically equivalent to each other, such that wherever one could be used, another could be used instead, ensuring thorough flexibility. This will prevent frustration of users when they are unable to combine disparate types of data into a single logical document, as would be their reasonable expectation. To make a system that is effective and useful, it should provide an interface, described here, to orient users and give them a guided workflow based on the information the IT system knows regarding them to help them get what they need to do done. (External apps should be possible to use, for instance as references to facilitate developing libre alternatives, as well as to provide historical access and allow verifying that libre alternatives are actually equivalent, but while they should be possible to use, they should never be <em>necessary</em> to use.)</p>
<p>For instance, there is no technical reason that italicized text can not be used in email subject lines, or for that matter, that an entire computer game could not be used as someone's email address. These restrictions are arbitrary and frustrating to people trying to work around them, and this computer system should resolve that by considering all types of information to be stored as simple strings of tokens, similar to current character encodings.</p>
<p>The data format used should provide mechanisms for storing the meanings of text, so that text in one language can be marked up in a manner that allows it to be machine-read without the ambiguities of a natural lanugage, and a facility provided for exporting that annotated text to various languages in the same manner that content can be exported to various data formats. This could make it easier to localize documents, by providing a way to tell the computer what text means and let it produce translations, without having to translate it to other languages by hand.</p>
<p>Developing an information technology system that integrates diverse types of data would improve efficiency and reduce frustration from unexpected, artificial limitations within computer systems for nearly any user of information technology systems. The number of personal computers was estimated to be “0.17 computers per person worldwide” in 2015 [Statista, n.d.]. 3.58 billion people are estimated to use the Internet [Statista, n.d. (b)]. This represents an enormous amount of people who use information technology systems, and it is likely that the majority of these would benefit from this proposal, especially those who work often with multimedia.</p>
<p>Another goal of this work is to create an information technology system that will help guide people with dementia and other mental disabilities. The WHO estimates that 47 million people have dementia. [WHO 2017] Another group of people who would likely find such tools useful is those with autism-spectrum learning disabilities. Entire worldwide population statistics for autism-spectrum disorders are not accurately known [Miller-Wilson, n.d.], but according to the WHO [WHO 2017b], estimated 1 in 160 children worldwide have autism-spectrum disorders, and according to the NIH [NIH, n.d.], estimated 1 in 68 within the United States. Finally, ordinary computer users would likely be able to benefit somewhat from the same systems, simply because while optimally designed tools may provide the greatest amount of benefit to those with challenges that affect their ability to use current systems, such tools would likely help everyone to some extent.</p>
<p>Because there are so many people affected by these challenges, and many others would likely benefit as well, there is a large group of people who would potentially find the proposed tools helpful. Consequently, working towards developing such a system is a valuable and important goal. The large potential benefit that could be gained from having such a system could, even if the individual increase in productivity were relatively small, have a substantial impact on the overall ability of humans to be productive and educated. In addition, a smaller group of people who are less able to use current information technology systems would probably see even larger gains in their productivity.</p>

 <h2>Information Technology Software Environment: Development practices</h2>


<!-- These are the principles the project is intended to follow. I did not follow them during this capstone project, because they do not prioritize creating working prototype software for demonstration, and instead prioritize creating reliable software that aligns with documentation and specification. Consequently, the code in its state at the end of the capstone has a range of capabilities, but is quite unreliable and poorly documented. Future work should adhere to these principles closely to get the software to work well again. -->
<ul>
    <li>Never remove a feature, capability, or option. If the development of an improved architecture or addition of new features involves scrapping existing code, reintroduce all previously existing capabilities before releasing the changes to the software.</li>
    <li>Make sure that all tests pass when releasing changes to the software.</li>
    <li>Thorough automated unit tests should be provided and kept passing.</li>
</ul>

<h3>Prerequisites for code to be added to the repository</h3>
    <ul>
        <li>Code must be readable and documented.</li>
        <li>Code must not cause or have failing tests.</li>
        <li>Code should include thorough automatic test coverage.</li>
        <li>To keep the software in line with the specification, code must address a deviation from the current specification (bug, missing feature, <span class="foreign-text">etc.</span>), and may not contain code unrelated to that.</li>
    </ul>

<h3>How issues should be prioritized</h3>
    <p>Ordered from highest priority to lowest priority:</p>
    <ol>
        <li>Potential for data loss</li>
        <li>Security vulnerabilities</li>
        <li>Functional regressions</li>
        <li>Incorrect results</li>
        <li>Crashes, lack of accessibility/internationalization, and similar critical usability issues</li>
        <li>Slow code with a significant impact on usability</li>
        <li>Aesthetic regressions</li>
        <li>Minor usability issues</li>
        <li>Slow code with a moderate impact on usability</li>
        <li>Missing features</li>
    </ol>

 <h2>Information Technology Software Environment: Implementation principles</h2>


<p>One of the fundamental elements of the information technology environment would be the creation of a decentralized information storage system, intended to provide effective and efficient information storage and retrieval (ISR). This would likely use an append-only NoSQL database to store a softly directed concept graph. Most or all knowledge can be effectively represented using two basic structures: nodes and relationships. Relationships would be specific types of nodes. Each node would correspond to a document stored as a sequence of character-like digital identifiers ("Dcs") analogous to both characters in a computer character encoding and to assembly language opcodes, allowing all types of electronic data to be stored as strings. These strings would be able to hold any structured data through the use of specific Dcs, such that when a document was added to the ISR system, it could be indexed deterministically into a separate database which would cache the structured information extracted from that document.</p>
<p>The nodes of a graph are the individual records that it stores. Relationships between those nodes are the edges of the graph, although it is possible that the system being developed will provide for more complex relationships, for example by allowing relationships to connect several nodes to each other in a variety of ways, although whether that proves necessary or useful remains to be seen. Metadata are an item’s traits: information such as the title of a node, or a description of it. The way the system is designed, placing all three of these types of entity into one table, allows relationships and metadata to have the attributes of nodes: for example, metadata could be attached to a relationship or another metadatum, or relationships could be specified that connect any combination of the three. There are many existing ISR systems, such as flat files and flat searching, flat-search filterable record sets, sorted records, a variety of tree and tree-like structures, tagged or labeled records, traditional tabular databases, relational databases, sparse tables, sparse matrices and entity-attribute-value models, graphs and digraphs, Boolean-queriable datasets, hierarchies, automated natural-language document acquisition and indexing, metadata-enriched natural-language document acquisition and indexing, and selective-display intelligent query results. The system proposed here would primarily leverage a graph structure augmented through the use of richly labeled nodes, providing great flexibility in the structures it can manage; in addition, the above structures could be emulated within a graph-driven environment for when they are preferred.</p>
<p>This will also provide effective options for implementing the wide variety of existing ISR systems outlined above as both self-hosted applications executed both in the cloud and in userspace.</p>
<p>There are a variety of content sources that would populate this ISR system: publicly available datasets, creative works, and other resources; resources added and/or created by individuals using the system; “dark” content such as is currently held by social networks, governments, and other organizations that do not publicly release their records; moderated content that has been reviewed and fact-checked and annotated as such by the Ember project NGO for supporting the model community; dynamically generated content; and computed content, for example, the results from a mathematical calculation or an operation on a dataset.</p>
<p>This ISR system should be leveraged by the NGO for several purposes. First, it can be used to record the individuals who are participants in the NGO. Through the development and application of a biometrics system, perhaps similar to that of India’s Aadhaar program, the use of names could be easily foregone, allowing for people who are mononymous, change their name frequently, have unconventional names, have no name, and so on and so forth to easily use the system, without being subjected to the usual tribulations that accompany any of the above in many modern governments. (It would also eliminate similar gender identity and other issues in receiving government services.) While instability of identification traits in individuals, either through subversion of the system or through chance, is indeed a concern, both for positive and negative identification (Sahoo, Choubisa, and Prasanna: “Multimodal Biometric Person Authentication: A Review”. 2012. In <em>IETE Technical Review</em>, vol. 29 issue 1, January–February 2012), hopefully a sufficiently deep set of metrics could be established to prevent this from being an issue. When an individual becomes part of the NGO, they would be enrolled in the biometric identification system, and provided a system for communication and tracking of some type. This could take several forms: the most practical and useful, probably, would be a wristwatch-like interface to cloud computing systems that would contain a GPS system and other useful electronics. The purpose of this would be the providing of emergency services: in the event of an emergency, the wearer could interact in it in a way to convey the existence and, if possible, the nature and situation of an emergency. This information would be entered automatically into the ISR system, which would provide a report of the emergency, including the person’s location, their direction and speed of travel, any known health conditions, their current health state (heart rate, blood pressure, and such). The system could automatically delegate the emergency to a nearby station of the NGO, which would act (presumably with the assistance of emergency response services) to resolve the situation.</p>
<p>Education and qualifications could be tracked through this system, as could taxes. For example, when a person completed testing by the organisation in a given subject, that score could be recorded in their profile in such a way that it could be used to determine what jobs they are allowed to work at. Taxation should be managed through time, so that a person would put in a certain number of hours of work selected from the jobs that need doing according to the ISR’s task record tracking system (possibly the number of hours necessary for a given amount of the organization’s services provided would be related to the level of qualification necessary for the work in question) to receive the organisation’s services in exchange. The person could choose which services to allocate their time credits to — for example, requesting food credits, requesting tickets to operas, or donating them to charity. In such a way, the taxes levied would hopefully never have to be put to a use the individual considered unethical. Inter-personal trading could also be facilitated through the ISR system. Such an information technology system to manage and facilitate work by individuals, tracking what needs to be done and what skills people have, and offering jobs to people with the relevant skills, would allow the individuals to bypass the difficult job search and application process, which uses a lot of individuals’ time and energy without producing any real value from that expenditure. Then, when a job is completed, the person who did the work would be granted credits corresponding to the work they did, which could then be exchanged for goods or services. This type of system could be implemented as a single, centralized system. However, it could also be implemented as a decentralized system.</p>
<p>To decentralize such a system, individual computers that make up the information technology system would have to be able to negotiate information sharing between other computers that are accessible via network. While implementing decentralization of the storage architecture, the API is in place, and once the separate OrbitDB project (<a href="https://github.com/orbitdb/orbit-db">https://github.com/orbitdb/orbit-db</a>) is more stable, it looks like it would provide an effective and practical basis for an implementation of this, if its dependencies and build-system do not prove too onerous to manage. If each individual computer has the entire capability to maintain the system, then the network would be able to split and recombine as needed depending on situation.</p>
<p>For instance, two geographically remote implementations of this system would be able to be connected when a network connection between them was available, being able to share work assignments remotely, but if a storm or other situation disrupted the network connection, the two communities’ economies would split into separate economies and continue working independently seamlessly, and then recombine when the network connection returned. In such a system, each individual who has a computer thus has access to and control over that part of the economy. This still leaves one centralized aspect, though, which is the software controlling the economies. If it is community-maintained libre software, that problem is largely eliminated, aside from the usual problems of project governance. If it is preferred, the software could also have facilities for creating ad-hoc centralization, where one instance of the software within each group of instances accessible within a given network would adopt the role of leader. This could be decided automatically, and made fully invisible to users of the system, or through community selection with automatic selection as a fallback, which would probably be preferable so as to ensure that systems with good connectivity and uptime (such as servers in datacenters) were selected as leaders, avoiding unnecessary inefficiency and maximizing reliability.</p>
<p>Thorough user group and subgroup support should be provided. This would be especially useful for facilitating collaboration between individuals, such as in business use of the software.</p>
<p>The EITE should be capable of ad-hoc computer network negotiation to ensure effective and practical decentralized operation.</p>

<h3>Target solution spaces</h3>

    <p>In summary, any current uses for software above the operating system level are reasonable areas to attempt development. An outline list of some is provided below. (Operating system development and hypothetical software use cases outside of exploration of the possibilities introduced by the novel information representation method may be of interest but are not priorities for this project at this time.)</p>

<h3>Semantic representation</h3>

    <p>There are two principle structural levels for which elements need to be described: documents and texts. A document is a complete unit such as a book or journal article, which would comprise various textual regions (note that in typesetting some items, such as database records of titles or filenames, only one textual region would be used; in the first, either a "Document Title" or a "Standard" region type would be used, depending on how the database was being queried, that is, the presentation style of the information as a title or as standard text (such as if it were being displayed in a page that contained a list of database fields), and in the second, a "Standard" region type would be used for interface display in lists (other region types might be used at other times) (note that in any use cases when it is in a "Standard" textual region, it would still have the text type Title)). A textual region is a section of content that has one semantic componency, <em>e.g.</em> the body of a document or the title; a document is therefore comprised of texts.</p>
    <ul>
        <li>Liberal relationship formation and node typing: A node can be assigned any other node as its type; a relationship can be from any type of node to any other type of node even if that is not how the relationship is defined (this situation could display a warning, for example).</li>
        <li>Authority contexts: Information should be able to be tagged with information on its authority. When used at the node level, as opposed to within document content, authority context information should be validated to ensure the utility of the available nodes (so that the authority context tagging can be used to evaluate the reliability of a given document). For instance, objective consensus, reflecting a neutral point of view, not necessarily trying to represent all points of view equally because of lack of consensus about them, versus subjective individual/organization source, representing an individual or organization's opinion, without necessarily any regard for a neutral point of view, such as in opinion writing or advertising.</li>
    </ul>
    <p>A node is a document, represented as a sequence of Dcs, stored in the EITE system. A document created by an individual would presumably, when stored as a node, have additional information not managed by the individual, such as who has the right to read and edit it. Thus, the document an individual would work with would be stored as a portion of a larger document representing its corresponding node. Because the system is append-only, nodes would have revisions, representing each time it was changed. For letter-by-letter changes, produced while typing without saving, instead of saving a new revision, letter-by-letter change tracking and storage could be used, such as is used by Etherpad.</p>
    <p>Various fully featured ways to interact with the system should be provided. For instance, a graphical interface, a command-line interface, and a UNIX-style "everything is a file" interface. (Filesystems, especially APIs exposed as filesystem entities have their own challenges and risks, such as confusing scripts that aren't designed to work with anything except plain old files, having unusual structures such as files not present in any directory, infinite directory trees resulting from hardlinks to directories, files with multiple forks, or named pipes, and if providing nodes by filename, having files and directories with the same names or directories with a data fork; these issues will need work and research to resolve well and provide good user experiences.)</p>

    <h4>Complex Dc sequences, Sequence Builders, and Dynamic Sets</h4>

        <p>A complex sequence of Dcs could be built using special-purpose input tools for constructing them. For instance, purpose-built tools could be provided for constructing a sequence of Dcs representing a mathematical equation, or a sequence of Dcs representing a given time or color.</p>
        <p>Similarly, a special type of sequence builder could be used to build sets of values. For instance, for selecting a document to send to someone, a document set builder dialog could be provided. It would allow selecting one or more documents to send manually, or selecting one or more documents by specifying rules for their selection. Then, the set containing the chosen node or nodes (optionally, at their present revision) is saved as a node; that set node is then provided to the person one is communicating to; the same interface could be used for selecting files for working with in an app. Sets could have restrictions, such as regarding how many documents they could contain, whether they could contain complex structures (such as a directory tree), whether one document could be swapped out with another or not, or whether the set should automatically gather new nodes matching the specified rules. Sets could also be driven by search criteria (<em>e.g.</em> the most relevant 10 nodes for a given keyword or given Boolean search conditions, or all four nodes with type Musician and a "is member of" relationship to "The Beatles", or the rapidly changing set of nodes with type Musician and a current or past "is member of" relationship to "Yes"), or built programmatically from new or existing nodes. Sets could also hold non-node strings. (Node IDs, as with everything else, can be considered as special cases of strings.) This would allow file uploads, searches, etc. to all be driven using the same basic user interface module, which would essentially be an extension of traditional file pickers. The set node would have a Dc sequence representation, as do all nodes, so this is really a Dc sequence builder. Like anything else in EITE, by virtue of being an append-only system, a set could "time travel": a set could display its contents as they would be at any past time. Another application of the set builder could be creating a document that displayed the current top 10 tracks on the Billboard Hot 100 — a set could be created representing the top 10, and a rule could be created if desired to deal with the condition if the Hot 100 was discontinued: the set could be configured to return nothing, to return a fixed list, to return the top 10 from the final edition of the charts, <em>et cetera</em>. A set builder could also be used to select dynamic and non-finite groups of things, such as the set of all integers, or all strings matching a given language syntax; this ability would be similar to the lazy evaluation used frequently in functional programming.</p>

 <h2>StageL: Simple staging language</h2>


<h3>Overview</h3>
    <p>StageL is a simple programming language for easily writing portable algorithms to be transpiled to and used by programs in other languages. It is the language used for, and was developed to be used for, the primary implementation of the <a href="http://futuramerlin.com/index.ftm">[http://futuramerlin.com/index.ftm]: Ember information technology environment</a> (EITE), and thus of the Dc-based document format used by EITE. The name "StageL" comes from calling it a "staging language" (which refers to its being a tool for developing the main EITE software, which should provide a more complete language).<!-- Also, "StageL" sounds catchy, and should be relatively easy to search for. It does seem reminiscent of "stage left" in theater, but that doesn't really have anything to do with it. --> This project was inspired by the ugly code that resulted when I tried to write using these principles directly in JavaScript, needing a lot of easy-to-mess-up boilerplate code and awkward notation (largely because it is not strongly typed).</p>
<h3>Design goals</h3>
    <ul>
        <li>Imperative language. Trivial to implement, learn, and read; extremely portable.</li>
        <li>Provide function calls, arrays, strings, numbers, booleans, and operators for these types with strict typing. Objects and first-class functions are out of scope for this language. (It's closer to duck-typed in practice, as e.g. in Bash there would be no distinction between string 0 and number 0.)</li>
        <li>Implemented as a transpiler that accepts a file as input and produces a file in the target language as output.</li>
        <li>Have an implementation of itself using itself, to provide testing and portability of the language.</li>
        <li>Have an implementation in Bash.</li>
        <li>Should transpile to (eventually) JavaScript, C, Java, Bash, PHP, Microsoft CIL, Lisp, x86 assembly, and Python, at least, in roughly that order of priority. (JavaScript has been completed for work on the main EITE software; C and Java should follow soon thereafter for their portability; the other languages are nice to have to cover a diverse range of development environments, and additionally, in the case of CIL/x86 assembly/Lisp, of providing interesting challenges in ensuring that the language really is easily portable due to their difference from the others.)</li>
        <li>Focus on simplicity and portability: it should purely be an algorithm representation format, without input/output capabilities. It is for implementing the algorithms of a program once, and having it be available in various languages. Things such as input/output and native calls should be provided as an API specification for the StageL source file: at the top of the file, it should declare all the implementation-dependent functions that it requires; these would then be provided separately by the programmer and/or by a set of functions provided with StageL for each target language. (This was loosened in practice and a standard library with some basic I/O is required.)</li>
        <li>All input/output to/from the language is as functions. All code must be in a function, with declared parameters, parameter types, variables needed, and return type. (The expense of the simple type system is that changing return values would break functions' API, since "out" parameters and/or pointers would not be available, but this should allow the code to be simple and readable, which is a priority for this language.)</li>
        <li>Output files should retain the structure and comments of the input files, thereby retaining readability as far as the target language permits.</li>
        <li>All behavior should be specified. Ambiguous programs should be impossible to write knowing the specification, and (as far as possible) the meaning of a program should be obvious and unambiguous <em>without</em> the language specification. Programs that do not match the specification exactly should be entirely rejected, rather than produce warnings or having a best guess of its meaning made.</li>
    </ul>
<h3>Actual results of the design goals</h3>
    <p>It works satisfactorily. It's pretty portable, I think. Things aren't fully specified because it transpiles to native constructs that behave differently between target languages. This could be resolved by implementing a virtual machine or similar in each target language, but that's a pain, so this is good enough for what this is for. Low-level facilities aren't really available yet. I guess they can be added as additional builtin routines. One option might be implementing a WebAssembly VM or something that is available implemented purely in StageL, but can be accessed natively if available to be faster.</p>
<h3>Syntax</h3>
    <p>Lines are separated by 0x0A. Each line consists of printable ASCII text: a–z, 0–9, apostrophe, slash, spaces, &lt;, &gt;, [, ], (, ), {, and }, and any other printable ASCII characters in string literals or comments (apostrophe is not yet available in string literals). Within a line is a sequence of space-delimited words. Semantic levels are denoted by four spaces' indentation. The first word in a line is a command. Comments (started with #) and string literals can contain any printable ASCII (although string literals can't contain ' because it's used to indicate them; this could probably be fixed easily enough at some point (TODO)). Identifiers can contain ASCII text a-z A-Z and 0-9 (but 0-9 may not be the first character, and code that relies on case sensitivity or insensitivity by having ident references differ only in case or having two idents that differ only in case is a (possibly un-notified-about) error (these are not technical restrictions; they're just required in the interest of portability)).</p>
    <p>There are a number of built-in commands in the core language, which is in core.js or whatever your output language is. There are also commands from the standard library, which is in portable.js.</p>
    <h4>Gotchas</h4>
    <ul>
        <li>Whitespace is (usually) significant. There isn't a 1:1 correspondence between valid source files and the parsed code, though, I don't think. Indentation must be with 4 spaces.</li>
        <li>Unexpected byte values in code files aren't allowed and should cause the parser to die; strings or comments containing byte values other than printable ASCII are an error.</li>
        <li>The value of a variable before it has been set in a given block is undefined; don't access it until it has been set (and don't rely on variable hoisting). That's an error, but there isn't anything in place to detect it.</li>
        <li>Argument lists can contain references to any type.</li>
        <li>Strings are not intended to be used for data interchange; rather they're for process-internal use for making semantically clear array mappings and such — they don't have any Unicode or binary-safe support, or even full printable ASCII support (' isn't supported in strings) for that matter. An integer array representing bytes is preferred for when you need to actually keep more careful track of data.</li>
        <li>Routine parameter types can be generic, string, number, bool, or array. Void is not an allowed parameter type (although I'm not sure what that would actually mean).</li>
        <li>Routine return types can be string, number, bool, array, or void. Generic return type is not allowed, separate routines for each return type desired must be used instead.</li>
        <li>Routines can be composed in argument lists, but unless you close the parameter lists explicitly using <code>}</code>, only one inner routine can be used per argument list; the inner routine must be the last argument. Using <code>}</code> or temporary variables is needed in other cases. For example: <code>set n/foo add 2 mod 7 5</code> sets n/foo to 4, but you can't do <code>set n/foo add mod 7 5 2</code> or <code>set n/foo add mod 7 5 mod 7 5</code> are errors, although they won't necessarily give an error (they will be interpreted as add(mod(7,5,2)) and add(mod(7,5,mod(7,5))) respectively, with the third argument to mod probably being discarded by the implementation). Instead, you can write these as <code>set n/foo add mod 7 5 } 2</code> or <code>set n/foo add mod 7 5 } mod 7 5</code>, respectively.</li>
        <li>Some commands (e.g. new, return) can't handle routines in argument lists; this <strong>should</strong> die with an error, but no promises.</li>
        <li>Referencing or assigning to a variable that has not been declared is an error, but there isn't anything in place to detect it.</li>
        <li>Code like:<pre><code>r/s/fbSwitcher n/num
    if eq 0 mod n/num 15
        return 'Buzz'</code></pre> is an error, because if the if statement is not true, the function will exit without returning (basically being a void). There's nothing in place to detect this, though. This example is from <code>cli/tests/stagel/js/routine-fbSwitcher-return-type/in/in.stagel</code>, which should perhaps be rewritten to not have this fault (ideally, a check for this problem would be added to the transpiler or generated code, but I can't be bothered right now). Likewise, routines with a return type but no return statement are an error without any detection.</li>
        <li>In assignments, calls, etc. where routines can be composed, they usually have to be evaluated strictly left to right. Thus, <code>set n/a sub len s/b 1</code> is an error (I don't think there is any detection for this): it will be interpreted as <code>set(n/a, sub(len(s/b, 1)))</code> when what is desired is <code>set(n/a, sub(len(s/b), 1))</code>. It should instead either use the inline-arglist-end marker <code>}</code> and be written as <code>set n/a sub len s/b } 1</code>, or be written as two statements: first <code>set n/a len s/b</code>, then <code>set n/a sub n/a 1</code>.</li>
        <li>Type constraints are generally only enforced when values are returned or given as parameters (in which case they are checked by code automatically inserted into the routine called during transpilation). Thus, for instance, you can assign the wrong datatype to a variable without it showing an error, and it will only die when it gets returned or passed to another routine.</li>
        <li>Array literals can (probably) only be used with the <code>set</code> command. For other things, make a temp value, assign the array literal to it, and then use the temp value in its place.</li>
        <li>Whitespace requirements apply to lines where the entire line is a comment, too.</li>
        <li>Comments have to be on their own lines.</li>
	<li>What's wrong with this code? <pre><code>    while lt 8 len an/res
                set an/res push [ 0 ] an/res
	</code></pre> The array bracket type doesn't match the content type: [ is for strings, while ( is for numbers.</li>
	<li><code><pre>set an/remainderArr anSubset an/in -5 -1 # last 4 characters</pre></code> breaks; the comment needs to be on a separate line.</li>
	<li>Code like <code><pre>set as/data append as/data [ s/key s/val ]</pre></code> is an error: array literals can't contain variables in their definitions.</li>
    <li>Perhaps test conditions should have to be on the same line as the test keyword. For example, <pre><code>if
    lt n/a 0</code></pre> would be an error; it should be written as <code>if lt n/a 0</code> instead. Previously it was intended to support splitting them onto separate lines, but it is tedious to implement, and somewhat makes the StageL code harder to read anyway. As a result, this perhaps should be an error.</li>
    <li><code>until</code> statements don't work (search for "This doesn't work. I guess it'll just be necessary to forgo split-line untils for now, although I'm not sure split-line commands are really desirable regardless. FIXME" in the code).</li>
    </ul>
    <h4>Example</h4>
    <pre><code>
r/s/fbSwitcher n/num
    if eq 0 mod n/num 15
        return 'FizzBuzz' # just a literal sequence of ASCII printable characters.
    # Comment
    if eq 0 mod n/num 5
        return 'Buzz' # Comment 2
        # Comment 3
    if # Could also write it like this, with the condition on another line
        eq 0 mod n/num 3
        return 'Fizz' # Comment 4

r/s/fizzBuzz # A string is an array of ASCII printable characters.
    # return-assert -n # the output should be non-empty.
    new n/counter 1
    until
        eq n/counter 100
        set n/counter add n/counter 1
        new s/temp ''
        set s/temp r/s/fbSwitcher n/counter
        return s/temp
</code></pre>

<h3>Special syntaxes</h3>
    <p>For loops aren't available because they add complexity to the transpiler.</p>
    <dl>
        <dt>if</dt><dd>conditional: bool, block</dd>
        <dt>else</dt><dd>if, bool, block, (elif, bool, block)..., else, block</dd>
        <dt>elif</dt><dd>if, bool, block, (elif, bool, block)...</dd>
        <dt>while</dt><dd>while, bool, block</dd>
        <dt>until</dt><dd>until, bool, block</dd>
        <dt>new</dt><dd>new ident</dd>
        <dt>set</dt><dd>set ident value</dd>
        <dt>}</dt><dd>End parameter list without new line</dd>
        <dt>{</dt><dd>Loop over an array. How it's used: <pre><code>new as/temp
set as/temp [ 'd' 'b' 'l' 'c' 'b' 'a' ]
new n/c
as/temp { n/i s/elem
    set n/c inc n/c
</code></pre>. This is shorthand for: <pre><code>new as/temp
set as/temp [ 'd' 'b' 'l' 'c' 'b' 'a' ]
new n/c
new n/i
new s/elem
while lt n/i count as/temp
    set s/elem get as/temp n/i
    set n/i inc n/i
    set n/c inc n/c
</code></pre></dd>
    </dl>

<h3>Scope</h3>
    <p>Values are available until the end of the block they are in. Whether they propagate outside of the block is undefined. Accessing them outside the block, or before the line they are defined, is an error, but there isn't anything in place to detect it. Use routine return values to move things around.</p>

<h3>Errors</h3>
    <p>When an error is encountered, it will produce a message somehow. Execution of the program may stop. Otherwise, behavior is undefined. For instance, in JavaScript in browser it will send a console log message. In bash, it will call "die" from ember-shared.</p>

<h3>Types and basic commands for them</h3>
    <p>Routines that have type "v" are void. These are all the primitive commands that are implemented natively for each language. Other commands are included in StageR library of useful commands. Type "g" is generic, can only be used as a parameter for a routine. It indicates it can be either string, int, or bool. Type "ga", can also only be used as a parameter, is a generic array, which is either an array of ints, an array of strings, or an array of bools (an array can't contain a mixture), and all arrays passed to a routine that accepts generic-array parameters must be the same type (e.g. all int arrays). Type "gi" (generic item(s)) is like "ga" but can also be a single bool, int, or string.</p>
    <h4>b: Booleans</h4>
        <p>Can be True or false. Can not be undefined (initialized to false).</p>
        <dl>
            <dt>r/b/and n/a n/b</dt><dd>Returns bool a and b</dd>
            <dt>r/b/or n/a n/b</dt><dd>Returns bool a or b</dd>
            <dt>r/b/not n/a n/b</dt><dd>Returns bool a not b</dd>
        </dl>
    <h4>n: Numbers (integer only)</h4>
        <p>Can be 0, or positive integer. Can not be undefined (initialized to 0). Currently is restricted to 32-bit signed (-2,147,483,648 to 2,147,483,647), but may be increased if more are needed.</p>
        <dl>
            <dt>r/n/add b/a b/b</dt><dd>Returns the sum of two numbers a and b</dd>
            <dt>r/n/sub b/a b/b</dt><dd>Returns the difference of two numbers a and b</dd>
            <dt>r/n/mod b/a b/b</dt><dd>Returns the modulo of two numbers a and b</dd>
        </dl>
    <h4>s: Strings</h4>
        <p>A sequence of characters: can be ASCII printable characters or space. No newlines or control characters, I guess. The string support isn't supposed to be very capable, just easy to implement lowest-common-denominator between target languages for making labels for stuff and whatever. For actual data, use arrays of integers.</p>
        <dl>
            <dt>r/s/substring s/input n/start n/end</dt><dd>Give the characters from start to end (indices as bytes (characters — no Unicode support here, sorry) into input)</dd>
            <dt>r/s/cat s/a s/b</dt><dd>Concatenates a and b</dd>
            <dt>r/n/len s/input</dt><dd>Gives the number of bytes of input.</dd>
        </dl>
    <h4>Basic type utility routines</h4>
        <p>These operate on str/int/bool.</p>
        <dt>r/s/strFrom g/input</dt><dd>Give string with contents.</dd>
    <h4>Array utility routines</h4>
        <p>A set of routines for managing arrays apply to any of the three array types (except the typed subset ones). Note that the push/append/prepend functions may not check that the type of the item being added to the array matches the array type; calling it with mismatched parameters is an error but may not be reported.
        <dl>
            <dt>r/a/copy gi/a gi/b</dt><dd>Set a to have the contents of b.</dd>
            <dt>r/a/push ga/array gi/value</dt><dd>Append the value to array. Same as r/an/append</dd>
            <dt>r/a/append ga/array gi/value</dt><dd>Append the value or array of values to array.</dd>
            <dt>r/a/prepend ga/array gi/value</dt><dd>Prepend the value or array of values to array.</dd>
            <dt>r/n/pop ga/array</dt><dd>Get the last element of the array.</dd>
            <dt>r/n/shift ga/array</dt><dd>Get the first element of the array.</dd>
            <dt>r/a(b,n,s)/a(b,n,s)Pop a(b,n,s)/array</dt><dd>Return the array without its last element.</dd>
            <dt>r/a(b,n,s)/a(b,n,s)Shift a(b,n,s)/array</dt><dd>Return the array without its first element.</dd>
            <dt>r/n/get ga/array n/index</dt><dd>Return the value of the array at index</dd>
            <dt>r/n/count ga/array</dt><dd>Return the number of elements in the array (also the maximum index; sparse arrays are not supported)</dd>
            <dt>r/v/setElement ga/array n/index gi/value</dt><dd>Set the indexth element of the array (0-indexed) to value. If value is an array, it will replace the following elements to its length.</dd>
            <dt>r/b/contains ga/array g/value</dt><dd>Returns "true" if the array contains the specified value.</dd>
            <dt>r/a(b,n,s)/a(b,n,s)Subset a(b,n,s)/array n/start n/end</dt><dd>Return the subset of the array from start index to end.</dd>
        </dl>
    <h4>an: Number Arrays</h4>
        <p>A sequence of numbers. Starts with a ( and ends with a ). E.g. <code>( 5 6 )</code>.</p>
    <h4>ab: Boolean Arrays</h4>
        <p>A sequence of bools. Starts with a &lt; and ends with a &gt;. E.g. <code>&lt; false true &gt;</code>.</p>
    <h4>as: String Arrays</h4>
        <p>A sequence of strings. Starts with a [ and ends with a ]. E.g. <code>[ "foo" "bar" ]</code>.</p>

<h3>StageR commands</h3>
    <p>These commands are implemented in StageL by composing the basic commands for easy portability. (Sorry, not really documented yet; look in implementation/portable/*.stagel to see what's available.)</p>
    <h4>Booleans</h4>
    <h4>Numbers</h4>
        <dl>
            <dt>r/n/add n/a n/b</dt><dd>Returns the sum of two numbers a and b</dd>
            <dt>r/n/sub n/a n/b</dt><dd>Returns the difference of two numbers a and b</dd>
            <dt>r/n/mul n/a n/b</dt><dd>Returns the multiplication of two numbers a and b</dd>
            <dt>r/n/mod n/a n/b</dt><dd>Returns the modulo of two numbers a and b</dd>
        </dl>
    <h4>Strings</h4>
        <dl>
            <dt>r/s/strCharAtPos s/input n/index</dt><dd>Give the character at index bytes (=characters — no Unicode support here, sorry) into input</dd>
        </dl>
    <h4>Arrays</h4>
 