<h1>Information Technology Software Environment: Document-Centric Computing Environment</h1>

<p class="breadcrumbs">Page location:
    <span><a href="/components.htm">Core project components</a></span>
    <span><a href="/specification">Specification</a></span>
    <span><a href="/specification/engineering-and-tech">Engineering and Technology</a></span>
    <span><a href="/specification/engineering-and-tech/information-technology">Information technology</a></span>
</p>

<h2>Introduction</h2>
    <h3>Abstract</h3>
        <p>This section of the Ember project specification introduces and documents the Ember computing environment, a project to develop a document-centric computing environment and data format. It is a proposal, design, specification, and (as of now prototype) implementation for an information technology system. The computing environment would be comprised of a centralized append-only information store, a computer operating system user interface integrated with that information store, and related specifications. The computing environment proposed here is distinct from existing technologies in that it attempts to provide superior flexibility by representing all information and documents it uses or processes (including its own software) as strings of text in a Unicode-based character encoding extended for this purpose. This is a work-in-progress draft, and everything here is subject to change and is not presently suited for implementation.</p>

    <h3>The Problem</h3>
        <p>Existing information technology systems have various unnecessary limitations. In addition, many existing information technology systems are not libre software. "Libre" refers to the ethical principle of freedom of knowledge, whereby knowledge is provided with the legal protection of rights such as modification and redistribution. (For specifics on this project's goals and strategies in libre licensing, see the "Licensing" section below.) This results in wasted effort on developing redundant proprietary technologies (for instance, multiple non-interoperable word processing apps), regressions in standards of living caused by the unavailability of proprietary systems (for instance, not being able to use the features of a previous version of a word processing app that some capabilities removed), and the incalculable loss of shared cultural heritage through inconsistent or nonexistent archival practices (and in many cases active hostility towards historical preservation, especially in the interest of short-term personal economic gain) (for instance, the loss of many historic films and television series to neglect or deliberate destruction).</p>
        <p>These problems are not hypothetical. They are very real and ongoing problems, and are actively causing very real and ongoing harm.</p>
        <p>While current computing hardware, and many other processes and aspects of society, have many of the same and similar problems as the problems in software that this subproject aims to address, this section only focuses on software. Other parts of the Ember project deal with computing hardware, industry and industrial designs, and social organization, so these areas are not addressed here.</p>
        <p>Information technology systems are not connected to each other effectively. While standard protocols for some types of data interchange are available, a single integrated IT system for building documents that leverage the full array of diverse types of information that can be represented using IT does not yet exist. In addition, current IT systems do not effectively orient their users and give them a sense of groundedness in regard to what they are doing.</p>

        <h4>Existing work towards solving this problem</h4>
            <p>Many existing projects address various aspects of the issues this project addresses. None seems to cohesively aim to integrate these aspects into a comprehensive libre framework and model implementation, though, driving the need for this project. For an annotated list of related projects and inspirations to this project, see the "Related projects and inspirations" section of the bibliography at the end of this document.</p>

<h2>General approach</h2>
    <p>This project should aim to systematically support the libre development and distribution as best as possible of an innovative information technology environment.</p>

    <h3>Current project status</h3>
        <p>"Ember Information Technology Environment" is the current name of this project.</p>
        <p>The primary components comprising the project are currently unfinished, but a variety of software maintained to facilitate the development of the project is available.</p>
        <p>A preliminary implementation of the computerized document representation format proposed herein is under development. An interpreter, several format converters, preliminary editing tool, and test suite and runner have been developed so far, as has a demonstration Web browser extension that allows authoring text in Web site text fields using the editing tool and automatically rendering sections of text in the document format embedded in Web pages. Continued work on the interpreter and implementation of the computing environment itself remain.</p>
        <p>The main functional output of the project so far has been the successful development of three well-tested, partially completed software applications that are currently used to facilitate the further development of the project. The first of these is a portable, easy-to-write, transpiled programming language for portable rapid application prototyping being used to develop the prototype implementation. The second of these is a static Web site generator, which is used to build the project's Web site (it includes working features for theming using CSS, with some included themes, automatic blog pagination, and discography Web site generation for musicians). The third of these is a suite of tools for working with file version tracking, document archiving, and data storage and distribution. It is currently in use for storing and managing the more than eleven million files and forty version control repositories used now for this proposal's parent project, as well as the structured archiving of more than eighteen million additional documents outside of the project.</p>

<h2>Intended outcomes</h2>
<ul>
    <li>The end goal of this work is the development of a completed, stable software environment used for developing the project, consisting of:
        <ul>
            <li>Specifications</li>
            <li>Information technology environment software implementation</li>
            <li>The cloud computing infrastructure should use a decentralized, asynchronously resolving append-only data store, similar to blockchains, to ensure the preservation and longevity of data stored using it as best as possible.</li>
        </ul>
    </li>
</ul>
<!--
<h2>Tasks list</h2>

    <h3>Planning and strategy</h3>
        <ul>
            <li>The most important tasks are also the most difficult. Developing assets (specifications, software, etc.) is trivial compared to developing communication skills and establishing allies. There's a reason there are several usable computer programs developed for this project, but no other people working on it.</li>
            <li>My role in this project should be to coordinate and facilitate until a person or persons more capable is/are available, and/or until it is self-managed, and my presence or absence would have no appreciable effect on it.</li>
        </ul>

< People and communication
- Develop effective communication skills and strategies.
  - That means being able to express clearly, succinctly, and persuasively the following (at least): _what_ this project is, _why_ it is important and achievable, and _how_ to help with it.
  - This includes both in writing and in person. Improving my in-person communication skills is especially important.

## Finances, budget, and stability
- Finances: Develop a financial strategy and budget requirements. As a single, close to broke student without employment or a degree (yet), or a rich family giving me a small loan of a million dollars, I can barely support keeping the lights on for the Web site. (Hosting is somewhere in the US$5/month range. The domain name registration (`futuramerlin.com`) is good through the end of 2022, at which point it will need renewal, which is about US$10/year.) The most recent costs of technical infrastructure is US$106.20 for three years of Web hosting, plus US$83.76 for eight year ownership of domain name. A rough estimate of the cost for the semester of Web hosting is therefore US$17.70, and the cost for the semester of the domain name is US$5.24.
- While the project still has a bus factor of 1, my personal stability is critical for the project. Barring exceptional circumstances, I should be able to continue working on it through graduation thanks to the university and government's student financial aid, and my family's financial support.
- Significant volunteer involvement and/or external investment will be necessary for a full implementation of this project.

### Detailed budget estimates

All figures are rough estimates.

#### Prototype and bootstrapping
```
Task                                Hours   Price/hr    Cost$   Price owner
===================================================================================================
Develop prototype                   400     10          4000    I volunteer to do my best
Fill out prototype                  1000    10          10000   I volunteer as much as I can
Web hosting costs                   unit(yr)120         120
TOTAL                               1400    10          14120
```

## Steps dependent on interpersonal connections
- Establish the physical community. This will require initial capital of *at least* tens of thousands of US dollars, as well as support for ongoing expenses.
- Create a non-profit organization to manage and be responsible for the project
- Ensure that organization's financial stability (through sources such as an endowment and grants)
- Transfer control of the project's assets (Web presence, etc.) to that organization

-->
<h2>Development tasks and process</h2>
<ul>
    <li>Develop, write, test, and document specifications
        <ul>
            <li>Information technology information and specifications, without external (non-libre) dependencies (enough information should be included to enable full construction of all technologies starting from nature, without any existing knowledge or technology/machinery; this should be <em>tested</em>)</li>
        </ul>
    </li>
    <li>Continue development of support software</li>
    <li>Develop software for information technology environment (EITE)
        <ul>
            <li>Provide and implement StageL inside EITE</li>
            <li>UI widgets</li>
            <li>Implement simple document editor in EITE</li>
            <li>Other EITE development tasks: networking, data storage and distribution, etc.</li>
            <li>Add C target to StageL</li>
            <li>Benchmark JavaScript implementation versus C→WebAssembly, out of curiosity. WASM would require clang in the toolchain, which wouldn't be ideal until clang can be run on non-WASM EITE, but anyway...</li>
            <li>Support WebAssembly in EITE</li>
            <li>Get text rendering and raster output implemented in EITE</li>
            <li>Complex text rendering support</li>
            <li>An alternative strategy could omit implementing the technology, and only focusing on developing the specification, although that strategy would risk increasing the problems the project is intended to fix (by providing existing IT companies with the project’s technological innovations, but not having a free/libre implementation of them to prevent existing companies using distorted clones of the idea to further their proprietary goals and vendor lock-in).</li>
        </ul>
    </li>
</ul>
<!-- 
# Resources needed

- Communication skills
- Strategic planning
- Team-building skills
- Financial support
- Time
- Stability
  - Financial
  - Personal (finances; energy and focus; time availability)
  - Organizational
-->

<h2>Overview</h2>
    <p>The computing environment will consist of the following components:</p>
    <ul>
        <li>Development principles, describing the process to use for creating the computing environment</li>
        <li>Data format and its representations
            <ul>
                <li>Specification</li>
                <li>Reference implementation</li>
            </ul>
        </li>
        <li>Data storage system and infrastructure: mechanism for storing append-only set of records, each comprising a unique ID paired with a node document</li>
        <li>Software system, including:
        <ul>
            <li>Client component</li>
            <li>Server components, including:
                <ul>
                    <li>Public-facing API</li>
                    <li>Search engine</li>
                    <li>Storage backend</li>
                </ul>
            </li>
        </ul></li>
    </ul>

<h2>Installation</h2>
    <p>Using the ebuild to install the software through Portage is suggested. Simple installation (untested) in case Portage or the ebuild is not suitable for your system: <code>git clone --depth 1 https://github.com/ethus3h/ember-information-technology-environment; cd ember-information-technology-environment; make autodep; ./configure; make; sudo make install</code>. <code>curl</code> must be available already.</p>
    <p>If you just build EITE without installing it, the built software will be placed in the "built/" folder. The structure of that folder corresponds to the /usr/share/eite/ folder when the software is installed. This is what is meant by the "EITE installation root" in this documentation.</p>

<h2>Development principles</h2>
<!-- These are the principles the project is intended to follow. I did not follow them during this capstone project, because they do not prioritize creating working prototype software for demonstration, and instead prioritize creating reliable software that aligns with documentation and specification. Consequently, the code in its state at the end of the capstone has a range of capabilities, but is quite unreliable and poorly documented. Future work should adhere to these principles closely to get the software to work well again. -->
    <ul>
        <li>Never remove a feature, capability, or option. If the development of an improved architecture or addition of new features involves scrapping existing code, reintroduce all previously existing capabilities before releasing the changes to the software.</li>
        <li>Make sure that all tests pass when releasing changes to the software.</li>
        <li>Thorough automated unit tests should be provided and kept passing.</li>
    </ul>
    <h3>Prerequisites for code to be added to the repository</h3>
        <ul>
            <li>Code must be readable and documented.</li>
            <li>Code must not cause or have failing tests.</li>
            <li>Code should include thorough automatic test coverage.</li>
            <li>To keep the software in line with the specification, code must address a deviation from the current specification (bug, missing feature, <span class="foreign-text">etc.</span>), and may not contain code unrelated to that.</li>
        </ul>
    <h3>How issues should be prioritized</h3>
        <p>Ordered from highest priority to lowest priority:</p>
        <ol>
            <li>Potential for data loss</li>
            <li>Security vulnerabilities</li>
            <li>Functional regressions</li>
            <li>Incorrect results</li>
            <li>Crashes, lack of accessibility/internationalization, and similar critical usability issues</li>
            <li>Slow code with a significant impact on usability</li>
            <li>Aesthetic regressions</li>
            <li>Minor usability issues</li>
            <li>Slow code with a moderate impact on usability</li>
            <li>Missing features</li>
        </ol>

<h2>Design goals</h2>
    <p>This section proposes developing an information technology system that allows various types of data to be given a first-class role. The proposed system is a centralized but non-centralization-dependent append-only information store, a computer operating system integrated with that information store, and related specifications.</p>
    <p>Web-based information technology companies such as Google, Amazon, and Facebook have a disproportionately large amount of power, have a disproportionately large role in how individuals are able to conduct their daily lives, and are single points of failure for a large portion of the modern lifestyle. These corporations are private institutions with little to no public oversight and control, despite having a large and visible role (perhaps even larger than any one government) in individuals’ lives. To begin to challenge that power structure, this semi-decentralized document-oriented computing platform should be developed that can integrate the abilities of traditional information technology systems into a single, cohesive system. Such a system should be free/libre software, and should be designed in such a way that it can adapt when needed to functioning as a fully decentralized, serverless system, transparently adjusting to the networking capabilities or lack thereof available to it on an ad-hoc basis. The existence of this project as a replacement would prevent single IT companies’ systems being single points of failure, and its distributed model would prevent it itself from being a single point of failure. Additionally, by being fully free/libre software, and by using a single system and data format for the full range of services, this proposal would reduce the dangers created by vendor lock-in, proprietary products, and incompatible IT systems.</p>
    <p>An important basic principle of EITE is flexibility. It should allow the user do what they want in an elegant manner, without undue shenanigans, difficult workarounds, or unwanted assistance. It should accommodate various workflows, and be thoroughly customizable. Its default configuration should be simple and easy to use. User interfaces should abstract away technical complexities by default while remaining fully usable, while allowing access to those complexities if desired.</p>
    <p>The system should use a single, libre, fully specified data format to store all types of information it processes, and development of the system should strive to ensure that a thorough selection of capabilities are provided out of the box using a consistent and customizable user interface, obviating the need for external apps (which often tend to be inconsistent in things such as internationalization and accessibility). The use of a single data format would allow, for instance, text, structured data, sound, and interactive media such as computer games to all be practically equivalent to each other, such that wherever one could be used, another could be used instead, ensuring thorough flexibility. This will prevent frustration of users when they are unable to combine disparate types of data into a single logical document, as would be their reasonable expectation. To make a system that is effective and useful, it should provide an interface, described here, to orient users and give them a guided workflow based on the information the IT system knows regarding them to help them get what they need to do done. (External apps should be possible to use, for instance as references to facilitate developing libre alternatives, as well as to provide historical access and allow verifying that libre alternatives are actually equivalent, but while they should be possible to use, they should never be <em>necessary</em> to use.)</p>
    <p>For instance, there is no technical reason that italicized text can not be used in email subject lines, or for that matter, that an entire computer game could not be used as someone's email address. These restrictions are arbitrary and frustrating to people trying to work around them, and this computer system should resolve that by considering all types of information to be stored as simple strings of tokens, similar to current character encodings.</p>
    <p>The data format used should provide mechanisms for storing the meanings of text, so that text in one language can be marked up in a manner that allows it to be machine-read without the ambiguities of a natural lanugage, and a facility provided for exporting that annotated text to various languages in the same manner that content can be exported to various data formats. This could make it easier to localize documents, by providing a way to tell the computer what text means and let it produce translations, without having to translate it to other languages by hand.</p>
    <p>Developing an information technology system that integrates diverse types of data would improve efficiency and reduce frustration from unexpected, artificial limitations within computer systems for nearly any user of information technology systems. The number of personal computers was estimated to be “0.17 computers per person worldwide” in 2015 [Statista, n.d.]. 3.58 billion people are estimated to use the Internet [Statista, n.d. (b)]. This represents an enormous amount of people who use information technology systems, and it is likely that the majority of these would benefit from this proposal, especially those who work often with multimedia.</p>
    <p>Another goal of this work is to create an information technology system that will help guide people with dementia and other mental disabilities. The WHO estimates that 47 million people have dementia. [WHO 2017] Another group of people who would likely find such tools useful is those with autism-spectrum learning disabilities. Entire worldwide population statistics for autism-spectrum disorders are not accurately known [Miller-Wilson, n.d.], but according to the WHO [WHO 2017b], estimated 1 in 160 children worldwide have autism-spectrum disorders, and according to the NIH [NIH, n.d.], estimated 1 in 68 within the United States. Finally, ordinary computer users would likely be able to benefit somewhat from the same systems, simply because while optimally designed tools may provide the greatest amount of benefit to those with challenges that affect their ability to use current systems, such tools would likely help everyone to some extent.</p>
    <p>Because there are so many people affected by these challenges, and many others would likely benefit as well, there is a large group of people who would potentially find the proposed tools helpful. Consequently, working towards developing such a system is a valuable and important goal. The large potential benefit that could be gained from having such a system could, even if the individual increase in productivity were relatively small, have a substantial impact on the overall ability of humans to be productive and educated. In addition, a smaller group of people who are less able to use current information technology systems would probably see even larger gains in their productivity.</p>

<h2>EITE specification</h2>
    <p>The specification of the interfaces that an EITE implementation should provide is available: <a href="spec">EITE specification Web page</a>.</p>

<h2>Implementation components</h2>
    <table>
    <thead><tr><th>Component</th><th>Implementation language</th><th>Description</th><th>Code location</th></tr></thead>
    <tbody>
        <tr><td><a href="stagel.htm">StageL</a> transpiler</td><td>bash</td><td>Translate .stagel files to other languages</td><td>cli/stagel-convert</td></tr>
        <tr><td>StageL's language-specific implementations</td><td>Implemented once for each StageL target language</td><td>Implementations of routines for StageL that are not implemented in StageL itself, but are instead implemented in its target languages.</td><td>implementation/core-implementations/</td></tr>
        <tr><td>Portable implementation</td><td>StageL</td><td>This is the software that parses and runs documents stored in the EITE document format. It comprises a set of routines implementing the EITE document format. This is a batch of StageL-native routines that are available to the programs implemented in StageL (which are, collectively, this portable implementation).</td><td>implementation/portable/</td></tr>
        <tr><td>Optional speedup code</td><td>Optionally implemented for each StageL target language</td><td>Functions can be provided here that are optimized, native implementations of existing StageR functions. Since StageR is unoptimized lowest-common-denominator code to keep things simple, this can help things run faster. These should only be <em>equivalent</em> to already existing StageR functions, and should not provide extra features, approximate implementations (e.g. if floats were supported, don't provide a fast inverse square root implementation here that produces different results than the one it's overriding), entirely new code, or (usually) functions that duplicate existing StageL core-implementation code (instead, optimize those, unless it makes them really unwieldy). If a language implementation includes these, it should be tested sometimes without them to make sure they aren't inadvertently required.</td><td>implementation/speedups/</td></tr>
        <tr><td>Data files</td><td>N/A</td><td>Data files used to implement EITE.</td><td>implementation/portable/</td></tr>
        <tr><td>Build scripts</td><td>bash (dep. on StageL transpiler)</td><td>Build EITE (usually invoked by "<code>make</code>"): builds StageL libraries (StageR at implementation/portable/portable.js, and StageL's language-specific native implementations of things at implementation/core-implementations/(lang)/core.(lang)) in various languages. Also combines and copies the finished JavaScript code into web/eite.js.</td><td>support/build-scripts/</td></tr>
        <tr><td>EITE document testing quick-runner</td><td>For now, bash, I guess? Or maybe js and run it in node to avoid having to add new StageL target language (dep. on EITE document format implementation)</td><td>Thin wrapper around the EITE document format implementation that gets the output of a document in its state after it's finished loading, for automated testing (would ignore things that are e.g. interactive or whatever).</td><td>(TODO)</td></tr>
        <tr><td>EITE document format tests</td><td>StageL</td><td>Test suite for EITE implementation.</td><td>web/tests.htm</td></tr>
        <tr><td>EITE document runner</td><td>Various platforms possible. For now, HTML+JS. (dep. on EITE document format implementation)</td><td>Thin wrapper around the EITE document format implementation that runs and displays a specified document.</td><td>(TODO)</td></tr>
        <tr><td>EITE non-native document editing tool</td><td>HTML, JavaScript (dep. on EITE document runner)</td><td>Tool for editing and running EITE-format documents before an EITE-native editing tool is available.</td><td>web/edit.htm (WIP)</td></tr>
        <tr><td>EITE-native user interface and platform, including document editing tool, and optional servers for search, ad-hoc networking, encryption keys, and node data storage and synchronization (optionally, able to be a master server, storing all nodes in the network).</td><td>EITE</td><td>A user interface and document editing tool. This is what's shown in the mockups e.g. <a href="http://futuramerlin.com/people/elliot/writings/blogs/elliotchandlernmd442/2017/12/06/12799819e/">here</a>. It would be used by running it using the EITE document format implementation. Thus, it could be used as the main interface to a computer, by booting directly into it. (I probably won't get it running outside of a Web browser this semester, as that's not a big priority for me right now, and it almost certainly won't be nearly as useful as mainstream operating systems or Web desktops, but I think that such capabilities would ultimately be ideal.)</td><td>web/main.htm (WIP)</td></tr>
    </tbody>
    </table>

<h2>Further principles</h2>
    <p>One of the fundamental elements of the information technology environment would be the creation of a cloud-based information technology system, intended to provide effective and efficient information storage and retrieval (ISR). This would likely use an append-only NoSQL database to store a softly directed concept graph. Most or all knowledge can be effectively represented using two basic structures: nodes and relationships. Relationships would be specific types of nodes. Each node would correspond to a document stored as a sequence of character-like digital identifiers ("Dcs") analogous to both characters in a computer character encoding and to assembly language opcodes, allowing all types of electronic data to be stored as strings. These strings would be able to hold any structured data through the use of specific Dcs, such that when a document was added to the ISR system, it could be indexed deterministically into a separate database which would cache the structured information extracted from that document.</p>
    <p>The nodes of a graph are the individual records that it stores. Relationships between those nodes are the edges of the graph, although it is possible that the system being developed will provide for more complex relationships, for example by allowing relationships to connect several nodes to each other in a variety of ways, although whether that proves necessary or useful remains to be seen. Metadata are an item’s traits: information such as the title of a node, or a description of it. The way the system is designed, placing all three of these types of entity into one table, allows relationships and metadata to have the attributes of nodes: for example, metadata could be attached to a relationship or another metadatum, or relationships could be specified that connect any combination of the three. There are many existing ISR systems, such as flat files and flat searching, flat-search filterable record sets, sorted records, a variety of tree and tree-like structures, tagged or labeled records, traditional tabular databases, relational databases, sparse tables, sparse matrices and entity-attribute-value models, graphs and digraphs, Boolean-queriable datasets, hierarchies, automated natural-language document acquisition and indexing, metadata-enriched natural-language document acquisition and indexing, and selective-display intelligent query results. The system proposed here would primarily leverage a graph structure augmented through the use of richly labeled nodes, providing great flexibility in the structures it can manage; in addition, the above structures could be emulated within a graph-driven environment for when they are preferred.</p>
    <p>This will also provide effective options for implementing the wide variety of existing ISR systems outlined above as both self-hosted applications executed both in the cloud and in userspace.</p>
    <p>There are a variety of content sources that would populate this ISR system: publicly available datasets, creative works, and other resources; resources added and/or created by individuals using the system; “dark” content such as is currently held by social networks, governments, and other organizations that do not publicly release their records; moderated content that has been reviewed and fact-checked and annotated as such by the Ember project NGO; dynamically generated content; and computed content, for example, the results from a mathematical calculation or an operation on a dataset.</p>
    <p>This ISR system should be leveraged by the NGO for several purposes. First, it can be used to record the individuals who are participants in the NGO. Through the development and application of a biometrics system, perhaps similar to that of India’s Aadhaar program, the use of names could be easily foregone, allowing for people who are mononymous, change their name frequently, have unconventional names, have no name, and so on and so forth to easily use the system, without being subjected to the usual tribulations that accompany any of the above in many modern governments. (It would also eliminate similar gender identity and other issues in receiving government services.) While instability of identification traits in individuals, either through subversion of the system or through chance, is indeed a concern, both for positive and negative identification (Sahoo, Choubisa, and Prasanna: “Multimodal Biometric Person Authentication: A Review”. 2012. In <em>IETE Technical Review</em>, vol. 29 issue 1, January–February 2012), hopefully a sufficiently deep set of metrics could be established to prevent this from being an issue. When an individual becomes part of the NGO, they would be enrolled in the biometric identification system, and provided a system for communication and tracking of some type. This could take several forms: the most practical and useful, probably, would be a wristwatch-like interface to cloud computing systems that would contain a GPS system and other useful electronics. The purpose of this would be the providing of emergency services: in the event of an emergency, the wearer could interact in it in a way to convey the existence and, if possible, the nature and situation of an emergency. This information would be entered automatically into the ISR system, which would provide a report of the emergency, including the person’s location, their direction and speed of travel, any known health conditions, their current health state (heart rate, blood pressure, and such). The system could automatically delegate the emergency to a nearby station of the NGO, which would act (presumably with the assistance of emergency response services) to resolve the situation.</p>
    <p>Education and qualifications could be tracked through this system, as could taxes. For example, when a person completed testing by the organisation in a given subject, that score could be recorded in their profile in such a way that it could be used to determine what jobs they are allowed to work at. Taxation should be managed through time, so that a person would put in a certain number of hours of work selected from the jobs that need doing according to the ISR’s task record tracking system (possibly the number of hours necessary for a given amount of the organization’s services provided would be related to the level of qualification necessary for the work in question) to receive the organisation’s services in exchange. The person could choose which services to allocate their time credits to — for example, requesting food credits, requesting tickets to operas, or donating them to charity. In such a way, the taxes levied would hopefully never have to be put to a use the individual considered unethical. Inter-personal trading could also be facilitated through the ISR system. Such an information technology system to manage and facilitate work by individuals, tracking what needs to be done and what skills people have, and offering jobs to people with the relevant skills, would allow the individuals to bypass the difficult job search and application process, which uses a lot of individuals’ time and energy without producing any real value from that expenditure. Then, when a job is completed, the person who did the work would be granted credits corresponding to the work they did, which could then be exchanged for goods or services. This type of system could be implemented as a single, centralized system. However, it could also be implemented as a decentralized system.</p>
    <p>To decentralize such a system, individual computers that make up the information technology system would have to be able to negotiate information sharing between other computers that are accessible via network. While implementing decentralization of the storage architecture, the API is in place, and once the separate OrbitDB project (<a href="https://github.com/orbitdb/orbit-db">https://github.com/orbitdb/orbit-db</a>) is more stable, it looks like it would provide an effective and practical basis for an implementation of this. If each individual computer has the entire capability to maintain the system, then the network would be able to split and recombine as needed depending on situation.</p>
    <p>For instance, two geographically remote implementations of this system would be able to be connected when a network connection between them was available, being able to share work assignments remotely, but if a storm or other situation disrupted the network connection, the two communities’ economies would split into separate economies and continue working independently seamlessly, and then recombine when the network connection returned. In such a system, each individual who has a computer thus has access to and control over that part of the economy. This still leaves one centralized aspect, though, which is the software controlling the economies. If it is community-maintained libre software, that problem is largely eliminated, aside from the usual problems of project governance. If it is preferred, the software could also have facilities for creating ad-hoc centralization, where one instance of the software within each group of instances accessible within a given network would adopt the role of leader. This could be decided automatically, and made fully invisible to users of the system, or through community selection with automatic selection as a fallback, which would probably be preferable so as to ensure that systems with good connectivity and uptime (such as servers in datacenters) were selected as leaders, avoiding unnecessary inefficiency and maximizing reliability.</p>
    <p>Thorough user group and subgroup support should be provided. This would be especially useful for facilitating collaboration between individuals, such as in business use of the software.</p>
    <h3>Target solution spaces</h3>
        <p>In summary, any current uses for software above the operating system level are reasonable areas to attempt development. An outline list of some <a href="target-solution-spaces-list.htm">is available</a>. (Operating system development and hypothetical software use cases outside of exploration of the possibilities introduced by the novel information representation method may be of interest but are not priorities for this project at this time.)</p>
    <h3>Semantic representation</h3>
        <p>There are two principle structural levels for which elements need to be described: documents and texts. A document is a complete unit such as a book or journal article, which would comprise various textual regions (note that in typesetting some items, such as database records of titles or filenames, only one textual region would be used; in the first, either a "Document Title" or a "Standard" region type would be used, depending on how the database was being queried, that is, the presentation style of the information as a title or as standard text (such as if it were being displayed in a page that contained a list of database fields), and in the second, a "Standard" region type would be used for interface display in lists (other region types might be used at other times) (note that in any use cases when it is in a "Standard" textual region, it would still have the text type Title)). A textual region is a section of content that has one semantic componency, _e.g._ the body of a document or the title; a document is therefore comprised of texts.</p>
        <ul>
            <li>Liberal relationship formation and node typing: A node can be assigned any other node as its type; a relationship can be from any type of node to any other type of node even if that is not how the relationship is defined (this situation could display a warning, for example).</li>
            <li>Authority contexts: Information should be able to be tagged with information on its authority. When used at the node level, as opposed to within document content, authority context information should be validated to ensure the utility of the available nodes (so that the authority context tagging can be used to evaluate the reliability of a given document). For instance, objective consensus, reflecting a neutral point of view, not necessarily trying to represent all points of view equally because of lack of consensus about them, versus subjective individual/organization source, representing an individual or organization's opinion, without necessarily any regard for a neutral point of view, such as in opinion writing or advertising.</li>
        </ul>
        <p>A node is a document, represented as a sequence of Dcs, stored in the EITE system. A document created by an individual would presumably, when stored as a node, have additional information not managed by the individual, such as who has the right to read and edit it. Thus, the document an individual would work with would be stored as a portion of a larger document representing its corresponding node. Because the system is append-only, nodes would have revisions, representing each time it was changed. For letter-by-letter changes, produced while typing without saving, instead of saving a new revision, letter-by-letter change tracking and storage could be used, such as is used by Etherpad.</p>
        <p>Various fully featured ways to interact with the system should be provided. For instance, a graphical interface, a command-line interface, and a UNIX-style "everything is a file" interface. (Filesystems, especially APIs exposed as filesystem entities have their own challenges and risks, such as confusing scripts that aren't designed to work with anything except plain old files, having unusual structures such as files not present in any directory, infinite directory trees resulting from hardlinks to directories, files with multiple forks, or named pipes, and if providing nodes by filename, having files and directories with the same names or directories with a data fork; these issues will need work and research to resolve well and provide good user experiences.)</p>
        <h4>Complex Dc sequences, Sequence Builders, and Dynamic Sets</h4>
            <p>A complex sequence of Dcs could be built using special-purpose input tools for constructing them. For instance, purpose-built tools could be provided for constructing a sequence of Dcs representing a mathematical equation, or a sequence of Dcs representing a given time or color.</p>
            <p>Similarly, a special type of sequence builder could be used to build sets of values. For instance, for selecting a document to send to someone, a document set builder dialog could be provided. It would allow selecting one or more documents to send manually, or selecting one or more documents by specifying rules for their selection. Then, the set containing the chosen node or nodes (optionally, at their present revision) is saved as a node; that set node is then provided to the person one is communicating to; the same interface could be used for selecting files for working with in an app. Sets could have restrictions, such as regarding how many documents they could contain, whether they could contain complex structures (such as a directory tree), whether one document could be swapped out with another or not, or whether the set should automatically gather new nodes matching the specified rules. Sets could also be driven by search criteria (_e.g._ the most relevant 10 nodes for a given keyword or given Boolean search conditions, or all four nodes with type Musician and a "is member of" relationship to "The Beatles", or the rapidly changing set of nodes with type Musician and a current or past "is member of" relationship to "Yes"), or built programmatically from new or existing nodes. Sets could also hold non-node strings. (Node IDs, as with everything else, can be considered as special cases of strings.) This would allow file uploads, searches, etc. to all be driven using the same basic user interface module, which would essentially be an extension of traditional file pickers. The set node would have a Dc sequence representation, as do all nodes, so this is really a Dc sequence builder. Like anything else in EITE, by virtue of being an append-only system, a set could "time travel": a set could display its contents as they would be at any past time. Another application of the set builder could be creating a document that displayed the current top 10 tracks on the Billboard Hot 100 — a set could be created representing the top 10, and a rule could be created if desired to deal with the condition if the Hot 100 was discontinued: the set could be configured to return nothing, to return a fixed list, to return the top 10 from the final edition of the charts, _et cetera_. A set builder could also be used to select dynamic and non-finite groups of things, such as the set of all integers, or all strings matching a given language syntax; this ability would be similar to the lazy evaluation used frequently in functional programming.</p>
    <h3>Implementation challenges and strategy</h3>
        <p>An implementation of a simple state-machine–driven interpreter of the token-based document format specification for the information technology environment aspect of the project is planned. There have been several previous attempts at developing this, but they have not worked out for various reasons. The first implementation was in PHP, and had poor architecture and rather unmaintainable code. A second attempt in Java was excessively ambitious in attempting to parse a programming-language-style document format interactively, without any specification and only minimal planning or architecture, as well as being highly overengineered. An attempt in PHP and JQuery to build a user interface toolkit based on these principles crashed and burned due to poor code architecture and attempting to “put the cart before the horse” in developing a UI toolkit without any specification for it, and without consideration of the existing (specified) aspects of the format. A fresh attempt in PHP stalled due to also being rather unmaintainable and awkwardly written, specifically in its use of dynamically written JavaScript, and trouble storing arbitrary binary content, independent of character encoding, in HTML text boxes (which are really the wrong tool for the job). An implementation in Bash was considered and a command-line interface designed for it, but probably this will simply become a wrapper around the JavaScript implementation. The JavaScript implementation here will attempt to avoid these issues by only implementing what has already been specified, not attempting to handle the programming-language-style format yet, using extensive unit tests (which was very helpful in the Java implementation), and using modularized code (which has been helpful in successful projects undertaken in the interim), and by planning the architecture of the code (shown in the diagram below) before implementing it. A staging language has been implemented in JavaScript to allow the code written for the project to be trivially portable to other platforms and languages.</p>
        <p>What I have been able to develop, practically speaking, is simply a technology demo and beginning of an implementation of a tool with larger scope. Consequently, it is rather limited in its practical utility, making it not suitable for a general audience, and mainly useful as a tool for demonstrating some of the principles used in this project, and as a core starting-point for the implementation of a more substantial and practically useful set of capabilities. StageL and the StageL-implemented library developed so far provide a solid technological foundation for further implementation of this project, and have practical applications outside of it as well.</p>
    <h3>The project in the context of new media studies: Alignment of the project approach to the traits of the currently emerging new media</h3>
        <p>Henry Jenkins's article "Eight Traits of the New Media Landscape" (http://nmdprojects.net/teaching_resources/jenkins_eight_traits_of_new_media.pdf) provides eight traits that its author observes in the prominent currently emerging new media. This section of the proposal evaluates this project's expression of this set of traits.</p>
        <p>The first of these traits is <em>innovation</em>. This project proposal is arguably merely an extension and refinement of existing systems, and so may not be considered true innovation, depending on perspective. Even in that case, however, because those existing systems are themselves innovative, this project remains a work within new media, even if it is not itself a new medium.</p>
        <p>The second trait is <em>convergence</em>. This proposal is highly convergent, being a broadly scoped project to innovate across a wide range of technology applications. It is intended to inherit the capabilities of existing computers, which are used for text, sound, image, video, and interactive media, among others.</p>
        <p>The third defining trait is <em>everyday</em> presence. As a project to develop a unified system providing all necessary technology infrastructure, if it is successfully completed and used to its envisioned potential, it would be able to serve as the framework for people's everyday lives. When only available in partial form, those portions of it can be used in everyday settings as well (<em>e.g.</em> large chunks of my classwork and other data I rely on and use on an everyday basis (personal projects, music library, email, etc.) are stored and managed using software developed in the course of developing this project).</p>
        <p>The fourth trait is <em>appropriation</em>. This proposed project ideally will be highly appropriative, because so much work has already been done. It would in all probability be hugely wasteful and impractical to attempt to build everything from scratch, rather than to leverage existing systems (even if only practical through inspiration!) and merely work to fill gaps and integrate the various existing technologies well. That said, reliance on proprietary or externally managed technologies should be eliminated as soon as practical, with all elements of the project and its dependencies being fully libre, because proprietary, non-maintainable, and trade-dependent systems are brittle and are a huge threat to the ability of human society to maintain its standards of living over time. Any external dependencies of the project should be libre, so they can be forked and maintained if necessary.</p>
        <p>The fifth trait is <em>networkedness</em>. As a design goal for this project, networking should be provided when available, but never mandatory. Systems that depend entirely on networking are, echoing the discussion of the fourth point, brittle. A cloud computing–backed virtual digital assistant, for instance, is thoroughly useless in the event of networking being unavailable. Once constructed, the best tools would be fully usable in a vacuum.</p>
        <p>The sixth trait is being <em>global</em>. The proposed project is intended to be able to be geographically dispersed.</p>
        <p>The seventh trait is <em>generational</em>. Whether an age gap will affect this project is hard to predict. If it does, it should only be by the choice of individuals, rather than by inaccessibility or prejudice: if people who are a different age than the majority involved in the project, those people should be provided any necessary accommodations to the fullest extent possible (medical care for the elderly, education for the young, and so on). This project should not engage in discrimination based on age, although it could only serve adults until a sufficient child protection framework is in place (<em>e.g.</em> I think Google doesn't allow kids to use it, so this presumably shouldn't either).</p>
        <p>The eighth trait is <em>inequality</em>. Unfortunately, this likely may affect the project initially, particularly due to economic barriers to access to information technology systems. Working to reduce undesired inequality as much as possible should be a design goal of the project, while promoting diversity and freedom.</p>

<h2>StageL</h2>
    <p>A simple programming language is provided for easily writing portable algorithms to be transpiled to and used by programs in other languages. It is the language in which the implementation of the Dc-based document format is implemented. See <a href="stagel.htm">its documentation page</a> for more information.</p>

<h2>Implementation process flow</h2>
    <p>This diagram shows conceptually how data flows at a high level in the process of running an EITE document using an interpreter (a compile-then-run system would use different data flows, but the overall effect would be equivalent). The non-bracketed elements represent programmed processes. The bracketed elements represent data structures. A circle ○ represents data storage persists for the lifetime of the document being open or being executed (not necessarily in RAM: for a long-running background task, like a periodic mail fetcher, this data could be moved to disk or the cloud if useful to free up local memory). Other data structures can be buffered/streaming FIFOs that discard input as it becomes unneccesary. The arrows represent data flows into and out of data storage or the system. This diagram assumes a Dc sequence as input; other forms of input would need a separate conversion/interpretation step for this.</p>
    <pre>         External I/O: document source ──────────────╮
               (as Dc sequence)                      │
                                                     ↓
   [○ Document execution state] ╮    ╭ [○ Document as Dc sequence] ←╮
                ↑               ↓    ↓                              │
                ╰───── Document execution loop:  ───────────────────╯
  Other External I/O ← iterates over tokens (Dcs)
                                   ↓
                              Renderer: converts and
                              and writes to renderer
                              buffer visible document
                              elements
                                     ↓
                              ⎡ Renderer buffer: holds     ⎤
                              ⎢ representation of document ⎥
                              ⎢ in the format desired for  ⎥
External I/O: render target ← ⎢ output (terminal text for  ⎥
(e.g. terminal or browser)    ⎢ a CLI, HTML for a browser, ⎥
                              ⎢ bitmap for a raster        ⎥
                              ⎢ monitor or HTML Canvas,    ⎥
                              ⎢ other formats for export,  ⎥
                              ⎣ etc.)                      ⎦</pre>

<h2>Data formats</h2>

<!--    <h3>Test suite</h3>
    <dl>
        <dt>eet</dt><dd>EITE execution test: given an input document in a specified format, run it and compare its output (the printable state of the document after it exits) to the expected output.</dd>
        <dt>ept</dt><dd>EITE parse test: given an input document in a specified format, parse it and compare its representation as a Dc list to the expected representation.</dd>
    </dl>-->
    <h3>EITE Language</h3>
        <h4>Objective</h4>
            <p>Develop a machine-readable language that can be used as an equivalent representation of documents represented as sequences of Dcs, for easier reading and editing by humans (using an ordinary text editor and conversion tool). It should also be able to be implemented using and transpiled into StageL.</p>
        <h4>Language profiles</h4>
            <p>EITE Language programs may optionally declare a non-default language profile to use: Core, Basic, and Dangerous (the default is "Standard"). Core and Basic both restrict the program to a subset of the language. The Basic language interpreter is written using the Core subset of the language, and provides useful shortcuts to use in the development of the interpreter for the Standard profile. The Default language interpreter is written using the Basic subset of the language, which will correspond to StageL. The Dangerous profile allows using language features which are probably a bad idea to use, but may be needed in some cases.</p>
        <h4>Dcs</h4>
            <p>The core unit of the EITE Language is the Dc (Document Component<!-- The name comes from "DCE Character", but is redefined for this context. -->). The defined Dcs are listed in DcData.csv. An EITE Language document is a list of Dcs, and a file is considered <em>structurally valid</em> if it can be interpreted as such. A Dc can have a syntactical pattern that it can require if it is to be meaningful. For example, a marker to <em>begin</em> a section of a document might be required to have a matching <em>end</em> marker. A document is only <em>syntactically valid</em> if the usage of each Dc contained within it conforms to the Dc's defined syntax, even if the document is otherwise structurally valid.</p>
            <h5>Reading DcData.csv</h5>
                <p>DcData.csv contains nine columns, each of which gives some information about a given Dc.</p>
                <p>From left to right, the columns are: ID, Name, Combining class, Bidirectional class, Simple case mapping, Type, Script, Details, and Description.</p>
                <p>The "ID" column specifies the number used to refer to a given Dc. Once an ID has been specified in a stable version, its meaning will not change in future versions.</p>
                <p>The "Name" column specifies an informative name for the Dc. The names may change in future versions if the current names seem suboptimal. They should not be relied on as unique or stable identifiers. If a name is prefixed with "!", then that Dc is deprecated. Names <em>should</em> be unique within any given version of DcData.csv, although errors in it could compromise that (it is not currently checked by a computer).</p>
                <p>"Combining class" column: See below.</p>
                <p>"Bidirectional class" column: See below.</p>
                <p>"Simple case mapping" column: This column contains the ID of the uppercase form of characters with the "Ll" type, and the ID of the lowercase form of characters with the "Lu" type.</p>
                <p>"Type" column: See below.</p>
                <p>The "Script" column indicates the script or other set to which the character belongs. Values needing further explanation include "Semantic", "DCE", "DCE sheets", "Noncharacters", "DCE versions", "Encapsulation", "EL Syntax", "EL Routines", and "EL Types".</p>
                <p>The "Details" column contains various additional information about characters, as a comma-separated list.
                    <ul>
                        <li>List entries beginning with "&gt;" are cross-references to related Dcs. List entries beginning with "&lt;" are decompositions.</li>
                        <li>List entries beginning with "(" indicate the syntax (parameter type signatures) for EITE Language routines.</li>
                        <li>List entries beginning with ":" indicate the required syntax for the given Dc, using a form similar to regular expressions:
                            <ul>
                                <li>a bracketed list of Dcs [] indicate a set of possible Dcs</li>
                                <li>a bracketed list of Dcs with a ^ at the beginning indicates an inversion of the set</li>
                                <li>+ indicates 1 or more of the preceding item</li>
                                <li>a Dc ID in brackets with a colon before the closing brackets indicates any syntactically correct sequence of Dcs beginning with the enclosed Dc ID</li>
                                <li>"~" represents the Dc the syntax of which is being defined</li>
                            </ul>
                        </li>
                    </ul>
                    The remaining list entries are aliases (alternate names for the characters, for ease of look-up).</p>
                <p>The "Description" column contains additional comments regarding the Dc.</p>
                <p>Three columns' contents are directly inherited from the Unicode Standard: Combining class (inherits Unicode's "Canonical_Combining_Class property"), Bidirectional class (inherits Unicode's "Bidi_Class" property), and Type (inherits Unicode's "General_Category" property). The "Simple case mapping" and "Script" columns should also be inherited from Unicode in some manner, but are not at present. For characters not included in Unicode, a reasonable value is chosen in the pattern of the values used by Unicode. If there are discrepancies between this value and Unicode's value for a given character that is in both sets, this should be reported as an error in the EITE Language standard. Unicode's values should take precedence.</p>
                <p>"Type" column values also extend the Unicode Standard's possible values with the "!Cx" category, denoting characters that do not fit neatly into Unicode's existing categories.</p>
            <h5>Notes on specific Dcs</h5>
                <h6>Dcs 241–245: Mode indicators</h6>
                    <p>Inclusion of the mode indicators in documents is <em>optional</em>. The selected mode expresses information about the document's expected execution environment. These modes are shortcuts that set up the environment in advance so that the document does not need to contain specific code to set up these contexts. This lets the resulting documents more concise and readable.</p>
                <h6>Dcs 246–255: Source formatting control</h6>
                    <p>Dcs 246 through 255 control the formatting of the ELS format version of a document.</p>
        <h4>Document formats</h4>
            <p>There are seven file formats defined by this specification. Six of them (dcBasenb, ELS, ELAD, ELQ, DELQ, and SELQ) are general-use formats, while the seventh (ERD, not yet specified) is a special-purpose format with a subset of the other formats' capabilities. DcBasenb and ELS are the primary formats, while ELAD, ELQ, DELQ, and SELQ are intended as an intermediate, more-readable format, and are not intended for information interchange (they are much larger than the other formats for a given document, in general).</p>
            <p><!-- To allow implementations to interpret documents created using newer versions of this format, once a completed version of this specification has been released, the meaning of any given Dc will not change. That will ensure that existing documents retain their meaning when interpreted using a newer version of the specification. While they are semantically stable, they are not necessarily presentation-stable (a Dc representing "A" in one version may look different from one version to the next, but it won't change to represent a "B"). --> Implementations should be able to render a document exactly (bit-for-bit) as determined by earlier versions of the specification. A syntax should be provided to indicate the version of the specification a given Dc, region of Dcs, or document should be displayed using (exactly, not just semantically), although Dcs have not been created for this purpose yet.</p>
            <p>There is a one-to-one correspondence within a given version of the specification and implementation between normalized dcBasenb, ELS, ELAD, ELQ, DELQ, and SELQ files (for any given document in one of those formats, there is only one way to represent it in the other formats), but not for ERD files (because ERD files can only represent a subset of EITE Language documents). That means that documents can be losslessly round-trip-converted between those six formats. <em>However</em>, when converting from an ELS file, if it does not have a version specified, its behavior may change due to changes in the mapping between source code and Dc IDs. Source form should be able to represent syntactically invalid documents unambiguously. Whether structurally invalid source-form documents should be able to be represented as structurally valid Dc sequences is debatable.</p>
            <p>DcBasenb files are a specific interpretation of the private-use-area characters in Unicode text.</p>
            <p>ELAD, ELS, ELQ, DELQ, and SELQ files are subsets of ASCII text files, with lines delimited by 0x0A (line feed). Bytes 0x00 through 0x09, 0x0B through 0x1F, and 0x7F through 0xFF (all ranges inclusive) are disallowed. Files must end with 0x0A. This may later be changed to use UTF-8.</p>
            <p>A less strictly specified formats has an implementation available: "integerList" (.dcil), which is a list of ASCII digits representing Dcs, with each Dc followed by a space (including the last one), and no trailing newline or comments.</p>
            <p>At the end of each format's summary (except for EMR), a simple "Hello, World!" document is given in the format.</p>
            <h5>EITE Language as Unicode Private Use Characters (dcBasenb), .dcbnb.utf8.txt (assuming UTF-8 representation of Unicode)</h5>
                <p>This format uses Unicode characters for Dcs that have losslessly roundtrippable Unicode equivalents, while representing Dcs that are not mappable to Unicode as sequences of Unicode private use area characters. Note that there are multiple possible ways a given Dc or sequence of Dcs can be represented as private use area characters, so only the normalized form (the form output by the implementation) is strictly roundtrippable to Dcs, and only for a given version of the specification and implementation (incidentally, the implementation for importing them does not verify that the normalized form was used and warn otherwise, but it should).</p>
                <pre><code>Hello, World!</code></pre>
            <h5>EITE Language source files (ELS), .els</h5>
                <p>EITE Language source files are a programming language–inspired representation of EITE Language documents. It is the most readable of the formats, but also (along with SELQ, which is defined in terms of it) the most technically complex.</p>
                <pre><code>dc:
    Hello, World!</code></pre>
                <p>or more idiomatically (but not the exact equivalent of the others in terms of the Dcs used),</p>
                <pre><code>say 'Hello, World!'</code></pre>
                <p>which would be</p>
                <pre><code>256 258 260 262 # . . . .
264 263 57 86 # . . H e
93 93 96 30 # l l o ,
18 72 96 99 # . W o r
93 85 19 261 # l d ! .
259 # .</code></pre>
                <p>in Dcs, or even more simply the <code>say</code> could be omitted since literals are printed by default: <code>'Hello, World!'</code>.</p>
            <h5>EITE Language in ASCII documents (ELAD), .elad</h5>
                <p>EITE Language in ASCII documents are a list of Dcs. The Dcs mappable to the permitted ASCII characters are represented by those ASCII characters, with the exception of 0x40 "<code>@</code>" (Dc 1). All other Dcs are represented by "<code>@</code>" followed by the integer Dc ID followed by a space, such that, for instance, "<code>@</code>" would be represented as "<code>@1 </code>".</p>
                <pre><code>Hello, World!</code></pre>
            <h5>EITE Language sequence files (ELQ), .elq</h5>
                <p>A list of Dc numbers. Four Dcs are given per line, separated by spaces.</p>
                <pre><code>57 86 93 93
96 30 18 72
96 99 93 85
19</code></pre>
            <h5>Documented EITE Language sequence files (DELQ), .delq</h5>
                <p>A variant of the EMS format for easier reading: after each line, the printable ASCII equivalent of each Dc is given following <code>0x202320</code>, each separated from the next by a space. If there is no printable ASCII equivalent, or the character is a space, "." is used instead.</p>
                <pre><code>57 86 93 93 # H e l l
96 30 18 72 # o , . W
96 99 93 85 # o r l d
19 # !</code></pre>
            <h5>Source-Documented EITE Language sequence files (SELQ), .selq</h5>
                <p>A variant of the ELQ and ELS formats for easier reading: the ELS source version is given in a comment in the style of the DELQ format, but the number of Dcs on each line is determined by the source lines to which they correspond.</p>
                <pre><code># dc:
57 86 93 93 96 96 30 18 72 96 99 93 85 19 #     Hello, World!</code></pre>
            <h5>EITE Record Documents (ERD), .erd</h5>
                <p>This is a special format in the "Structured" mode used for structured record storage in EITE. It is not yet defined, but will most likely be a subset of one of the other formats.</p>
        <h4>Structures in the EITE Language</h4>
            <p>The EITE Language uses the following main types of entity to represent information:
                <dl>
                    <dt>Type</dt><dd>Types are templates describing the structure of objects. They are known as prototypes or classes in most programming languages, depending on whether objects described by them inherit changes to the types made after the object was created. (Objects can be used as types by casting.) Type names begin with a capital letter when in source form.</dd>
                    <dt>Object</dt><dd>An object is an entity that conforms to a given type (an <em>instance</em> of that type). The most general type is <em>object</em>, and there is no need for an object to conform to any other type. Whether the type it inherits from is treated as a class or a prototype should be able to be specified.</dd>
                    <dt>Block</dt><dd>A block is a group of statements.</dd>
                    <dt>Project</dt><dd>A project is a single document, and if relevant, any other documents maintained as part of that document.</dd>
                    <dt>Module</dt><dd>A module is one or more Library-mode documents that have a package name for addressing the things they provide.</dd>
                    <dt>List</dt><dd>A list is an ordered list of objects.<!-- An inline list is begun by <code>[</code> and terminated by <code>]</code>. Example: <code>listName=["a" [5 6] $b]; say $listName[0]</code> stores three Objects in a list named <code>listName</code> and prints <code>a</code>. Objects can be given custom identifiers for addressing them by separating them using <code>: </code>, in which case they should be additionally separated by <code>, </code>. Example: <code>listName=[foo: "a", bar: [5, 6], baz: b]; say $listName[foo]</code>.--></dd>
                    <dt>String</dt><dd>A string is a list of Dcs. Because all Dcs can be used in strings, any data type can be cast to a string, and all data types internally <em>are</em> strings of Dcs.<!-- An inline list is begun by <code>"</code> and terminated by a second <code>"</code>. In source form, <code>"</code> and <code>\</code> must be escaped using <code>\</code>. Example: <code>stringName="Hello, \"World\"!"</code> stores the string <code>Hello, "World"!</code> in a string named <code>stringName</code>. Strings can be concatenated by placing them beside each other: <code>a="foo"; b="baz"; say $a"bar"$b</code> prints <code>foobarbaz</code>.--></dd>
                    <dt>Routine</dt><dd>A routine is a set of instructions for a computer to follow as part of the process of interpreting a document. Similar concepts are known as functions or subroutines in most programming languages, or as methods when used within objects. Routines have an associated structure that indicates what parameters may be passed to it.<!-->; they will be accessible through a list named <code>!par</code>, and if named, then also through their names. Specifying a return type for a routine is optional. If none is specified, it will be treated as "void", meaning no return type is expected. It is denoted by <code>()</code> followed by a block of statements, with its structure, if desired, within the parentheses. Example: <code>String foo(String, String qux?, *){say $!par[1]$!par[2]$qux}; foo("bar" "baz"); foo("bar" 6 "qux") # qux is 6, param 0 is bar, param 1 is 6, and param 2 is qux; foo(qux=6 "bar") # qux is still 6, but now parameter 0 is 6 and 1 is bar</code> represents an unnamed (positional-only) string parameter, an optional string parameter named "qux", and an unknown number (zero or more) of additional parameters of any type, and prints <pre><code>bazbaz
6qux6
bar6</code></pre>. Because literals are printed by default when at the beginning of a statement, the "invoke" routine must be used to invoke a routine in some cases, such as when referencing a routine by a name stored in a variable or constant: <code>a="I! Am! An! Awkward! Identifier!"; $a(){say "blob"}; invoke $a</code>. An alternative syntax for routine invocation, omitting parentheses, can be used if desired: <code>foo(String, String qux?){}; foo qux=6 bar</code>--></dd>
                    <dt>Operator</dt><dd>An operator is a short notation or syntax pattern for some common routines<!-- (e.g., <code>Number a + Number b</code> in place of <code>add(Number a, Number b)</code>, or <code>if true; then say 'Hello, World!'; else die</code> in place of <code>if(true, (){say 'Hello, World!'}, (){die})</code>)-->.</dd>
                    <dt>Identifier</dt><dd>An identifier is a name for an object.<!-- They are indicated by <code>$</code>, except for identifiers for routines, which do not have the <code>$</code> prefix. Before the <code>$</code> a type signature is often present. Except for routines, <code>!</code> following the <code>$</code> indicates a language-defined identifier, and must be escaped if used as the first character of a custom identifier. For routines, the pattern is inverted: <code>!</code> before an identifier indicates that a custom routine is being referenced (it must be included in calls to <code>invoke</code>, as well). <code>(</code> following the <code>$</code> indicates a special value, not a normal identifier, using Bash's syntax: <code>$(say "foo"; say "bar")</code> represents the output of the code between the <code>(</code> and the <code>)</code>, and <code>$(&lt;foo)</code> represents the contents of the file <code>foo</code>.--></dd>
                    <dt>Structure</dt><dd>A structure is the definition of what the structure is that an entity can have, similar to type definitions or type signatures in some programming languages. A type can contain named Structures without any values for defining an interface.</dd>
                    <dt>Statement</dt><dd>A statement is a logical line of a document. It can be an invocation of a routine, or a declaration of an entity's structure or value.</dd>
                </dl>
            </p>
<!-- 
                <p>Routines with some dangerous properties must be labeled accordingly, as follows:
                    <dl>
                        <dt>cs!</dt><dd><span class="important-letter">C</span>hangeable routine <span class="important-letter">s</span>ignature (subtypes don't need to use this routine's signature when overriding it.)</dd>
                        <dt>nd!</dt><dd><span class="important-letter">N</span>on-<span class="important-letter">d</span>eterministic</dd>
                    </dl>
                </p>
            <h5>Object hierarchy</h5>
                <p>All objects are addressed through a hierarchy:
                <dl>
                    <dt>lang</dt><dd>Basic language Objects and Routines (automatically included)</dd>
                    <dt>system</dt><dd>Objects and Routines related to the Ember environment</dd>
                    <dt>math</dt><dd>Objects and Routines related to mathematics</dd>
                </dl>
                </p>

            <h5>Types</h5>
                <p>Types have CamelCase names beginning with an uppercase letter.</p>
                <h6>C Type</h6>
                    <dl>
                        <dt>Traits</dt><dd>C Type$type</dd>
                        <dt>Routines</dt><dd>C cs!this.$type:new(FuzzyList$params) { lang.new(this) }</dd>
                    </dl>

                <h6>C Routine</h6>
                    <dl>
                        <dt>Traits</dt><dd>
                            <ul>
                                <li>C String$code</li>
                                <li>C (Null|Routine)$onExit</li>
                            </ul></dd>
                        <dt>Routines</dt><dd><ul>
                            <li>C Any:run(FuzzyList$params) { lang.run(this,lang.cast($params,List,"return")) }</li>
                            <li>C Boolean:compare(Any$object) { /* return true if this object is identical to $object */ }</li>
                        </ul></dd>
                    </dl>

                <h6>C List</h6>
                    <dl>
                        <dt>Traits</dt><dd>
                            <ul>
                                <li>B List{set this.$allowedTypes=lang.new(List).add(Type)}$allowedTypes: List of allowed types that can be put in this list</li>
                                <li>C Natural$last: last valid index</li>
                                <li>C Natural$count: number of entries</li>
                                <li>B (Null|Natural)$entryLimit: number of entries that the list may hold; defaults to Null (meaning unlimited)</li>
                                <li>S (Null|Natural)$indexLimit: maximum index the list may use; defaults to Null (meaning unlimited)</li>
                            </ul></dd>
                        <dt>Routines</dt><dd>
                            <ul>
                                <li>B Void:add(String$value|List$value) { this.insert(this.last()+1) }</li>
                                <li>B Void:set(Natural$index,(String$value|List$value)) { lang.set(this.record($index),$value) }</li>
                                <li>B Any:get(Natural$index) { lang.get(this.record($index)) }</li>
                                <li>C Reference:record(Natural$index) { lang.getListEntry(this,$index) }</li>
                                <li>B Void:insert(Natural$index,(String$value|List$value)): insert $value at $index, moving the current $index and following items ahead by $value.count() if it's a list, and by 1 if it's a string</li>
                            </ul></dd>
                    </dl>

                <h6>C FuzzyList (inherits from List)</h6>
                    <p>When a FuzzyList is used in a list, its contents are appended to the list, and it is deconstructed. When a FuzzyList is used in the declaration of the parameters of a Routine, its first elements, starting from 0, are set to the values of the parameters passed to the Routine from its position onwards (so, for example, if the parameters declared are Natural$a,Natural$b,FuzzyList{ lang.set(lang.trait(this.entryLimit),2) }$c,Natural$d,Natural$e and it gets called with 2,3,4,5,6,7,8, then that's an error because there's no place to put 6 (the 5th parameter) (but if the entryLimit weren't set, a=2,b=3,c=(4,5,6),d=7,e=8), and if it gets called with 2,3,4,5,6,7, a=2,b=3,c=(4,5),d=6,e=7).</p>

                <h6>C Resource</h6>
                    <dl>
                        <dt>Traits</dt><dd></dd>
                        <dt>Routines</dt><dd></dd>
                    </dl>

            <h5>System object: Traits</h5>
                <p>Traits have camelCase names beginning with a lowercase letter. Routines are a type of trait.</p>
                <dl>
                    <dt>C nd!List[Resource]:system.resources</dt><dd>List of resources (I/O, etc) available.</dd>
                    <dt>C nd!String:system.implementation</dt><dd>Description of the language backend.</dd>
                </dl>

            <h5>System object: Routines</h5>
                <p>Routines have camelCase names beginning with a lowercase letter, and have parameters.</p>
                <h6>C Void:lang.run(Routine$routine,List$params)</h6>
                    <dl>
                        <dt>Exceptions thrown</dt><dd>!routineSyntaxError, !parameterNumberMismatch, !parameterTypeMismatch</dd>
                        <dt>Notes</dt><dd>Determinism depends on String:$routine.code.</dd>
                    </dl>
                <h6>C (Void|$type):lang.cast(Any$object,Type$type,(|String$return))</h6>
                    <dl>
                        <dt>Return value</dt><dd>None, unless $return="return" in which case it returns an object of type $type</dd>
                        <dt>Exceptions thrown</dt><dd>!incompatibleTypeError</dd>
                        <dt>Notes</dt><dd>If $return="return", determinism depends on types of objects (specifically, on value of String:$object.cast:$type.code).</dd>
                    </dl>
                <h6>C (Void|$trait.type):lang.set(Reference$trait,Any$value,(|String$return))</h6>
                    <dl>
                        <dt>Return value</dt><dd>None, unless $return="return" in which case it returns an object of type $trait.type</dd>
                        <dt>Exceptions thrown</dt><dd>!targetTypeMismatch</dd>
                        <dt>Notes</dt><dd>If $return="return", determinism depends on $value.</dd>
                    </dl>
                <h6>C $trait.type:lang.get(Reference$trait)</h6>
                    <dl>
                        <dt>Return value</dt><dd>An object of type $trait.type</dd>
                        <dt>Exceptions thrown</dt><dd>(none additional)</dd>
                        <dt>Notes</dt><dd>Determinism depends on $trait.</dd>
                    </dl>
                <h6>C Reference:lang.trait(Any$object)</h6>
                    <dl>
                        <dt>Return value</dt><dd>A reference to the object passed to it</dd>
                        <dt>Exceptions thrown</dt><dd>(none additional)</dd>
                        <dt>Notes</dt><dd>(none)</dd>
                    </dl>
                <h6>C Boolean:lang.compare(Any$left,Any$right)</h6>
                    <dl>
                        <dt>Return value</dt><dd>lang.and($left.compare($right),$right.compare($left))</dd>
                        <dt>Exceptions thrown</dt><dd>(inherit from $left.compare and $right.compare)</dd>
                        <dt>Notes</dt><dd>(none)</dd>
                    </dl>
                <h6>S Any:lang.otherwise(Routine$left,Routine$right)</h6>
                    <dl>
                        <dt>Return value</dt><dd>try { return $left }; except { return $right }</dd>
                        <dt>Exceptions thrown</dt><dd>(inherit from $left and $right)</dd>
                        <dt>Notes</dt><dd>(none)</dd>
                    </dl>
-->
<h2>Prototype</h2>
    <p>Two interactive mockups are available for this project, to allow you to explore a more completed version of the proposed tools as if you were using them.</p>
    <p>The earlier interactive prototype is available in work-docs/Mockups/12799819e/index.html, while the more recent one is available in work-docs/Mockups/Web-Mockup/index.html.</p>
<h2>User interviews and user testing</h2>

    <p>To learn about how viable and helpful this project would be, I interviewed two people to learn about their use of information technology systems and how they would be affected by the tools proposed here.</p>
    <h3>Interview questions</h3>
    <ol>
        <li>What tasks do you frequently use information technology (IT) systems to complete? A few examples of information technology systems, for purposes of this question, are computers, telephones, portable music players, and fax machines.</li>
        <li>What aspects of yourself influence your use of, and experience of using, information technology systems? For example, if your job needs you to use IT systems, what is that job and what aspects of it relate to your use of IT systems? Or, if you find IT systems difficult to use because of difficulty processing complex visual stimuli, or because of physical mobility impairments.</li>
        <li>Also, when using information technology systems, are there any other challenges that you face?</li>
        <li>Imagine a computer or smart phone that, when you first start it, presents a list of recent projects you have worked on (such as documents you have had opened), and a list of upcoming projects you have told it about. Would you find a memory aid like that helpful in guiding you to the projects you are there to work on?</li>
        <li>For the next two questions, imagine an IT system that gives you information about current circumstances — your name, where you are, the date and year, and recent news and messages.
        <ol>
            <li>Would that help you feel grounded in the present and more easily able to complete the tasks you are there to work on?</li>
            <li>If you or someone you know has trouble remembering that sort of state information, for instance due to Alzheimer’s disease or dementia, do you think this would be helpful in dealing with that?</li>
        </ol></li>
        <li>Current information technology systems are generally unable to facilitate combining information from various domains of use. For example, if you are writing a textual document, it is not really possible to include a musical composition within that document in such a way that it can still be edited when you send the document to someone else, and that it is a first-class, native feeling part of the document. For the next two questions, consider an IT system that uses a single way of storing and manipulating information for all the types of information it works with. For instance, you could work with a text document and a musical recording within a single document, using a single interface, or you could use a video as the subject of an email.
        <ol>
            <li>Would you find such a system helpful?</li>
            <li>What are some specific situations in your use of IT systems that would benefit from that?</li>
        </ol></li>
    </ol>
    <p>Thank you for participating in the interview!</p>

    <h3>Responses</h3>
    <p>Note that these responses have been lightly edited to make them clearer. The meaning of the responses is unchanged.</p>
        <h4>Interviewee 1</h4>
            <p>Interviewee 1 works as a church organist and piano teacher.</p>
            <ol>
                <li>Computer: Researching music repertoire and performance techniques for my work; learning repertoire; listening to music for work. Telephone: Business and personal contacts.</li>
                <li>No problems except for not always understanding the technology in a complete way and so not always being able to solve problems on my own.</li>
                <li>Financial restrictions in not having all the ideal components for a virtual pipe organ. Also, sometimes information not fitting on a screen correctly, or otherwise not working as it should.</li>
                <li>I don’t have so many projects going at once that I cant keep track of them.</li>
                <li>
                <ol>
                    <li>Perhaps if I had a condition like Alzheimer's disease, but otherwise, no. Recent news would be a distraction unless that was my field of work.</li>
                    <li>Yes, it could be helpful. I believe.</li>
                </ol></li>
                <li>
                <ol>
                    <li>Yes, that could be helpful. It would prevent the need to make two (or possibly more) separate communications, in some cases.</li>
                    <li>Trying to share a photo with commentary attached or a musical composition with my questions attached and also to get a critique.</li>
                </ol></li>
            </ol>
        <h4>Interviewee 2</h4>
            <ol>
                <li>I use IT systems for many tasks:
                    <ul>
                        <li>Music writing and recording</li>
                        <li>Music listening</li>
                        <li>Video watching</li>
                        <li>Reading books</li>
                        <li>Reading news</li>
                        <li>Checking the weather</li>
                        <li>Studying Spanish</li>
                        <li>Looking up words in English and other languages</li>
                        <li>Finding synonyms</li>
                        <li>Making phone calls</li>
                        <li>Texting</li>
                        <li>Video chatting</li>
                        <li>Keeping my appointments straight</li>
                        <li>As an alarm clock</li>
                        <li>As a timer</li>
                        <li>As a stopwatch</li>
                        <li>Tuning my guitar</li>
                        <li>Finding information about people and businesses</li>
                        <li>To guide my travels via GPS</li>
                        <li>Emailing</li>
                        <li>Research of products and subjects of interest</li>
                        <li>Backing up information</li>
                        <li>Storing photos</li>
                        <li>Digitizing music and photographic slides</li>
                        <li>Scanning books and other documents</li>
                        <li>Finding, creating, and sharing recipes</li>
                        <li>Journaling</li>
                        <li>Making and publishing videos</li>
                        <li>Publishing digital music</li>
                        <li>Taking photos</li>
                        <li>Opening the garage door</li>
                        <li>Making shopping lists</li>
                        <li>As a metronome</li>
                        <li>To create editable documents using OCR</li>
                        <li>To measure the level of sound</li>
                        <li>To create animation</li>
                        <li>To practice piano</li>
                        <li>To recreate orchestras</li>
                        <li>To alter photos</li>
                    </ul>
                </li>
                <li>My work is in music, and I use a computer and an iPhone extensively to support that work, as can be gleaned from the list above.<br />
                As long as images are relatively static, I can manage OK visually, although my eyes will get tired. When things are moving quickly, it is a challenge even when my eyes are fresh. Watching a movie with subtitles can be a challenge, for instance.</li>
                <li>Because I often interact with others via video chat, internet connection issues can often present challenges.<br />
                Because I use IT systems so extensively in my work, I am often challenged by the fact that my formative years did not include "thinking like a computer." In other words, using IT systems is not second nature to me.</li>
                <li>I think I would have to be shown how it would intersect with my workflow. I am used to using Calendar to keep my appointments straight, and I use Notes to make lists of projects when they become too numerous to hold in my "internal memory," so to speak. I am generally reluctant to learn new applications when what I am using is basically working for me, but when I am shown that it is in my best interest to do so, I overcome the reluctance.</li>
                <li>
                <ol>
                    <li>I have such an IT system. I can ask Siri for any of that information.</li>
                    <li>I think it could be helpful, especially if someone was still in the work force, or if they still were striving to meet the challenges of living alone, or of helping to care for others.</li>
                </ol></li>
                <li>
                <ol>
                    <li>I think it would be brilliant. Helpful? Absolutely.</li>
                    <li>Oh, goodness. I might send a recording to a client, and in the email mention specific passages about which I wanted them to comment; with such a holistic system, focusing their attention would be easy. Again, I sometimes send links to YouTube videos I have posted, and it would be great if it weren't necessary for the recipient to leave the email client in order to view and comment.<br />
                    When creating text documents, I often want to incorporate photos or other materials; it is always a struggle because the applications that are best for the text aren't as nimble when managing other materials. I can absolutely see the value in being able to incorporate both video and sound files, for instance, in such documents.<br />
                    Also, it would be wonderful to be able to add recorded verbal content (or even video) as a response to emails or other documents received from others. It is often easier and faster to speak impressions and complex responses to things than to write them.</li>
                </ol></li>
            </ol>
        <h4>Summary of findings</h4>
            <p>These interview responses show that various aspects of the proposed information technology system would be helpful. The interviews find some parts of the project helpful and others not necessarily so for their specific goals. Consequently, to make the proposed system ideal for all users, a method should be provided to allow users to choose which of its capabilities they would like to use. That way, the interface they have is the most relevant to them personally, and thus the most helpful in solving the particular problems they face.</p>
    <h3>Personas</h3>
        <p>While these personas are based on the interview respondents, they are somewhat fictionalized.</p>
        <h4>Persona 1</h4>
            <p>Lara is a 37-year-old professional church organist. They make extensive use of computers to manage business communications, and to simulate an organ for practice at home. Their work often requires communicating with their employer regarding music and business. To discuss music with their employer, it is often not practical to use a computer, and it is necessary to meet in person, due to the limitation of current information technology systems. If computers could provide tools for easily sharing and collaborating on scores and recorded performances of those scores, Lara’s job would be made easier by reducing travel time and the requirement of meeting in person to work on things that do not actually need an in-person meeting.</p>
        <h4>Persona 2</h4>
            <p>Joseph is a 40-year-old film teacher at a large public university. They use non-linear editing software in computers to edit films, and to demonstrate film editing in class to their students, as well as to work on separate projects for independent clients. Because the people they work for often have a hard time communicating what they want in a project, several iterations of work and feedback are needed before a finished product is delivered. Consequently, Joseph would be better able to communicate with students and clients if they could work with film in the way their non-linear editing software allows, but collaboratively online with the clients and students, like cloud-based collaborative word processors allow. If there were a single editing tool for text and films, the same collaboration abilities from one medium would be available in others, making Joseph’s job a lot easier and allowing more efficient communication between Joseph and their clients.</p>
    <h3>Proposed user acceptance testing strategy</h3>
        <p>To test the viability of this project, I would suggest developing a functional instance of it, and presenting it to a range of users who work with various challenges to using information technology systems. For testing the general viability of the project, it would not be necessary to fully implement all the features that would be needed to make it competitive with other information technology systems; rather, it would only be needed to implement a representative subset of capabilities that would allow the users to explore the general interface and the system’s basic interaction structure. To gather data on challenges that users might encounter in using the system, the testers should be presented with a task to complete using the system, and asked to give commentary on their experience of the tool, and any frustration they encounter during the process, while they work on completing the assigned task. An article from the Nielsen Norman Group states that “A scripted study of product usage is done in order to focus the insights on specific usage aspects, such as on a newly redesigned flow.” [Rohrer, 2014] Consequently, that seems like the correct user testing strategy for determining the viability of this proposal, and finding roadblocks in its usability.</p>
    <h3>Feedback about Extension Tool for Elliot’s Capstone Project
March 4, 2019
I have seen and attempted to use two versions of this tool. The earlier version worked more
completely for testing purposes, and from that I got a clear idea of how the tool might be
useful, both in general, and for me personally.
It would be helpful to have a succinct description of the various elements and their
relationships, as the layout does not make that immediately clear. For instance, the left-to-right
orientation of the tabs at the bottom of the page at first suggested to me that perhaps each of
the three would be used in any one application, whereas their use is not sequential.
It seems as though an unnecessary amount of space is allowed for the “Click to Insert” list,
both vertically and horizontally. The list itself is not in an obvious order, and so locating a
desired value takes more time than seems ideal. A search feature of this list might make it more
navigable.
Having the dropdown menus perhaps within the main buttons that they modify would help me
visually.
When this tool is ready for use, I would find it useful on my website for displaying musical
excerpts within the context of textual analysis of musical compositions. Likewise, on my
YouTube channel, it will be useful for displaying the opening measures of music for multi-
movement works, as an aid to navigation within a video.
I would also find it useful to create custom buttons for my online store.
I might also use this tool when collaborating with other musicians and writers for instant
messaging musical ideas, especially when editing or suggesting changes for performance.
And it will be great to have the option of displaying mere italics in Messages on my iPhone!
